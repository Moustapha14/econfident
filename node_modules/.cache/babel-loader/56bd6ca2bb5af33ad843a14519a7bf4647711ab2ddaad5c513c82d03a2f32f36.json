{"ast":null,"code":"'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst regx = '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'.replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false,\n  //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true,\n  //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  tagValueProcessor: function (a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function (a, attrName) {\n    return a;\n  },\n  stopNodes: []\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\nconst props = ['attributeNamePrefix', 'attrNodeName', 'textNodeName', 'ignoreAttributes', 'ignoreNameSpace', 'allowBooleanAttributes', 'parseNodeValue', 'parseAttributeValue', 'arrayMode', 'trimValues', 'cdataTagName', 'cdataPositionChar', 'tagValueProcessor', 'attrValueProcessor', 'parseTrueNumberOnly', 'stopNodes'];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n  return val;\n}\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/\\.?0+$/, \"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.parseTrueNumberOnly);\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\nconst getTraversalObj = function (xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n  //function match(xmlData){\n  for (let i = 0; i < xmlData.length; i++) {\n    const ch = xmlData[i];\n    if (ch === '<') {\n      if (xmlData[i + 1] === '/') {\n        //Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        let tagName = xmlData.substring(i + 2, closeIndex).trim();\n        if (options.ignoreNameSpace) {\n          const colonIndex = tagName.indexOf(\":\");\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if (currentNode) {\n          if (currentNode.val) {\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData, options);\n          } else {\n            currentNode.val = processTagValue(tagName, textData, options);\n          }\n        }\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = [];\n          if (currentNode.attrsMap == undefined) {\n            currentNode.attrsMap = {};\n          }\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1);\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\");\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\");\n      } else if (xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\");\n        const tagExp = xmlData.substring(i, closeIndex);\n        if (tagExp.indexOf(\"[\") >= 0) {\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        } else {\n          i = closeIndex;\n        }\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9, closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if (textData) {\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);\n          textData = \"\";\n        }\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n        i = closeIndex + 2;\n      } else {\n        //Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i + 1);\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if (separatorIndex !== -1) {\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n        if (options.ignoreNameSpace) {\n          const colonIndex = tagName.indexOf(\":\");\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if (currentNode.tagname !== '!xml') {\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);\n          }\n        }\n        if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n          //selfClosing tag\n\n          if (tagName[tagName.length - 1] === \"/\") {\n            //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          } else {\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if (tagName !== tagExp) {\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        } else {\n          //opening tag\n\n          const childNode = new xmlNode(tagName, currentNode);\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex = closeIndex;\n          }\n          if (tagName !== tagExp && shouldBuildAttributesMap) {\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    } else {\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n};\nfunction closingIndexForOpeningTag(data, i) {\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === '>') {\n      return {\n        data: tagExp,\n        index: index\n      };\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n    tagExp += ch;\n  }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  const closingIndex = xmlData.indexOf(str, i);\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\nexports.getTraversalObj = getTraversalObj;","map":{"version":3,"names":["util","require","buildOptions","xmlNode","regx","replace","nameRegexp","Number","parseInt","window","parseFloat","defaultOptions","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","tagValueProcessor","a","tagName","attrValueProcessor","attrName","stopNodes","exports","props","processTagValue","val","options","trim","parseValue","parseTrueNumberOnly","resolveNameSpace","tagname","tags","split","prefix","charAt","length","shouldParse","parsed","isNaN","indexOf","String","isExist","attrsRegx","RegExp","buildAttributesMap","attrStr","matches","getAllMatches","len","attrs","i","undefined","Object","keys","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","textData","ch","closeIndex","findClosingIndex","substring","colonIndex","substr","getValue","includes","child","attrsMap","startIndex","parent","tagExp","childNode","addChild","result","closingIndexForOpeningTag","data","index","separatorIndex","shouldBuildAttributesMap","lastIndexOf","attrBoundary","str","errMsg","closingIndex","Error"],"sources":["/Users/macbook/Documents/projet ipssi/temp-repo-chatbot/frontend/node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"],"sourcesContent":["'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: []\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'stopNodes'\n];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/\\.?0+$/, \"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.parseTrueNumberOnly\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function(xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n//function match(xmlData){\n  for(let i=0; i< xmlData.length; i++){\n    const ch = xmlData[i];\n    if(ch === '<'){\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if(currentNode){\n          if(currentNode.val){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);\n          }else{\n            currentNode.val = processTagValue(tagName, textData , options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = []\n          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\")\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\")\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\")\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0){\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        }else{\n          i = closeIndex;\n        }\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData){\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      }else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1)\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if(separatorIndex !== -1){\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){//selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          }else{\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        }else{//opening tag\n\n          const childNode = new xmlNode( tagName, currentNode );\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex=closeIndex;\n          }\n          if(tagName !== tagExp && shouldBuildAttributesMap){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n}\n\nfunction closingIndexForOpeningTag(data, i){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          data: tagExp,\n          index: index\n        }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}