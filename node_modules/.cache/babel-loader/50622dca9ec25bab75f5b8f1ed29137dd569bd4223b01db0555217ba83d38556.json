{"ast":null,"code":"import { __asyncValues, __awaiter, __extends, __generator, __values } from \"tslib\";\nimport AsyncStorageDatabase from './AsyncStorageDatabase';\nimport { OpType, QueryOne } from '../../types';\nimport { DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR, getIndex, getIndexFromAssociation, traverseModel, validatePredicate, inMemoryPagination, keysEqual, getStorename, getIndexKeys, IDENTIFIER_KEY_SEPARATOR } from '../../util';\nimport { StorageAdapterBase } from './StorageAdapterBase';\nvar AsyncStorageAdapter = /** @class */function (_super) {\n  __extends(AsyncStorageAdapter, _super);\n  function AsyncStorageAdapter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  // no-ops for this adapter\n  AsyncStorageAdapter.prototype.preSetUpChecks = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/];\n      });\n    });\n  };\n\n  AsyncStorageAdapter.prototype.preOpCheck = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\n   * Open AsyncStorage database\n   * Create new DB if one doesn't exist\n   *\n   * Called by `StorageAdapterBase.setUp()`\n   *\n   * @returns AsyncStorageDatabase instance\n   */\n  AsyncStorageAdapter.prototype.initDb = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var db;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            db = new AsyncStorageDatabase();\n            return [4 /*yield*/, db.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, db];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.clear()];\n          case 1:\n            _a.sent();\n            this.db = undefined;\n            this.initPromise = undefined;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AsyncStorageAdapter.prototype.batchSave = function (modelConstructor, items) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelName, namespaceName, storeName, keys, batch, _loop_1, this_1, items_1, items_1_1, item;\n      var e_1, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (items.length === 0) {\n              return [2 /*return*/, []];\n            }\n            modelName = modelConstructor.name;\n            namespaceName = this.namespaceResolver(modelConstructor);\n            storeName = getStorename(namespaceName, modelName);\n            keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n            batch = [];\n            _loop_1 = function (item) {\n              var model = this_1.modelInstanceCreator(modelConstructor, item);\n              var connectedModels = traverseModel(modelName, model, this_1.schema.namespaces[namespaceName], this_1.modelInstanceCreator, this_1.getModelConstructorByModelName);\n              var keyValuesPath = this_1.getIndexKeyValuesPath(model);\n              var instance = connectedModels.find(function (_a) {\n                var instance = _a.instance;\n                var instanceKeyValuesPath = _this.getIndexKeyValuesPath(instance);\n                return keysEqual([instanceKeyValuesPath], [keyValuesPath]);\n              }).instance;\n              batch.push(instance);\n            };\n            this_1 = this;\n            try {\n              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n                item = items_1_1.value;\n                _loop_1(item);\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n            return [4 /*yield*/, this.db.batchSave(storeName, batch, keys)];\n          case 1:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype._get = function (storeName, keyArr) {\n    return __awaiter(this, void 0, void 0, function () {\n      var itemKeyValuesPath;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            itemKeyValuesPath = keyArr.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n            return [4 /*yield*/, this.db.get(itemKeyValuesPath, storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.save = function (model, condition) {\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var _b, storeName, connectionStoreNames, modelKeyValues, fromDB, result, connectionStoreNames_1, connectionStoreNames_1_1, resItem, storeName_1, item, instance, keys, itemKeyValues, fromDB_1, opType, e_2_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = this.saveMetadata(model), storeName = _b.storeName, connectionStoreNames = _b.connectionStoreNames, modelKeyValues = _b.modelKeyValues;\n            return [4 /*yield*/, this._get(storeName, modelKeyValues)];\n          case 1:\n            fromDB = _c.sent();\n            this.validateSaveCondition(condition, fromDB);\n            result = [];\n            _c.label = 2;\n          case 2:\n            _c.trys.push([2, 9, 10, 15]);\n            connectionStoreNames_1 = __asyncValues(connectionStoreNames);\n            _c.label = 3;\n          case 3:\n            return [4 /*yield*/, connectionStoreNames_1.next()];\n          case 4:\n            if (!(connectionStoreNames_1_1 = _c.sent(), !connectionStoreNames_1_1.done)) return [3 /*break*/, 8];\n            resItem = connectionStoreNames_1_1.value;\n            storeName_1 = resItem.storeName, item = resItem.item, instance = resItem.instance, keys = resItem.keys;\n            itemKeyValues = keys.map(function (key) {\n              return item[key];\n            });\n            return [4 /*yield*/, this._get(storeName_1, itemKeyValues)];\n          case 5:\n            fromDB_1 = _c.sent();\n            opType = fromDB_1 ? OpType.UPDATE : OpType.INSERT;\n            if (!(keysEqual(itemKeyValues, modelKeyValues) || opType === OpType.INSERT)) return [3 /*break*/, 7];\n            return [4 /*yield*/, this.db.save(item, storeName_1, keys, itemKeyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR))];\n          case 6:\n            _c.sent();\n            result.push([instance, opType]);\n            _c.label = 7;\n          case 7:\n            return [3 /*break*/, 3];\n          case 8:\n            return [3 /*break*/, 15];\n          case 9:\n            e_2_1 = _c.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 15];\n          case 10:\n            _c.trys.push([10,, 13, 14]);\n            if (!(connectionStoreNames_1_1 && !connectionStoreNames_1_1.done && (_a = connectionStoreNames_1.return))) return [3 /*break*/, 12];\n            return [4 /*yield*/, _a.call(connectionStoreNames_1)];\n          case 11:\n            _c.sent();\n            _c.label = 12;\n          case 12:\n            return [3 /*break*/, 14];\n          case 13:\n            if (e_2) throw e_2.error;\n            return [7 /*endfinally*/];\n          case 14:\n            return [7 /*endfinally*/];\n          case 15:\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.query = function (modelConstructor, predicate, pagination) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, storeName, namespaceName, queryByKey, predicates, hasSort, hasPagination, records;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.queryMetadata(modelConstructor, predicate, pagination), storeName = _a.storeName, namespaceName = _a.namespaceName, queryByKey = _a.queryByKey, predicates = _a.predicates, hasSort = _a.hasSort, hasPagination = _a.hasPagination;\n            return [4 /*yield*/, function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                var keyValues, record, filtered, all;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (!queryByKey) return [3 /*break*/, 2];\n                      keyValues = queryByKey.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n                      return [4 /*yield*/, this.getByKey(storeName, keyValues)];\n                    case 1:\n                      record = _a.sent();\n                      return [2 /*return*/, record ? [record] : []];\n                    case 2:\n                      if (!predicates) return [3 /*break*/, 4];\n                      return [4 /*yield*/, this.filterOnPredicate(storeName, predicates)];\n                    case 3:\n                      filtered = _a.sent();\n                      return [2 /*return*/, this.inMemoryPagination(filtered, pagination)];\n                    case 4:\n                      if (!(hasSort || hasPagination)) return [3 /*break*/, 6];\n                      return [4 /*yield*/, this.getAll(storeName)];\n                    case 5:\n                      all = _a.sent();\n                      return [2 /*return*/, this.inMemoryPagination(all, pagination)];\n                    case 6:\n                      return [2 /*return*/, this.getAll(storeName)];\n                  }\n                });\n              });\n            }()];\n          case 1:\n            records = _b.sent();\n            return [4 /*yield*/, this.load(namespaceName, modelConstructor.name, records)];\n          case 2:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.getByKey = function (storeName, keyValuePath) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.get(keyValuePath, storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.getAll = function (storeName) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.getAll(storeName)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.filterOnPredicate = function (storeName, predicates) {\n    return __awaiter(this, void 0, void 0, function () {\n      var predicateObjs, type, all, filtered;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            predicateObjs = predicates.predicates, type = predicates.type;\n            return [4 /*yield*/, this.getAll(storeName)];\n          case 1:\n            all = _a.sent();\n            filtered = predicateObjs ? all.filter(function (m) {\n              return validatePredicate(m, type, predicateObjs);\n            }) : all;\n            return [2 /*return*/, filtered];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.inMemoryPagination = function (records, pagination) {\n    return inMemoryPagination(records, pagination);\n  };\n  AsyncStorageAdapter.prototype.queryOne = function (modelConstructor, firstOrLast) {\n    if (firstOrLast === void 0) {\n      firstOrLast = QueryOne.FIRST;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var storeName, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            storeName = this.getStorenameForModel(modelConstructor);\n            return [4 /*yield*/, this.db.getOne(firstOrLast, storeName)];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, result && this.modelInstanceCreator(modelConstructor, result)];\n        }\n      });\n    });\n  };\n  AsyncStorageAdapter.prototype.deleteItem = function (deleteQueue) {\n    var e_3, _a, e_4, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, _d, deleteItem, storeName, items, items_2, items_2_1, item, keyValuesPath, e_4_1, e_3_1;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _e.trys.push([0, 17, 18, 23]);\n            _c = __asyncValues(deleteQueue);\n            _e.label = 1;\n          case 1:\n            return [4 /*yield*/, _c.next()];\n          case 2:\n            if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 16];\n            deleteItem = _d.value;\n            storeName = deleteItem.storeName, items = deleteItem.items;\n            _e.label = 3;\n          case 3:\n            _e.trys.push([3, 9, 10, 15]);\n            items_2 = __asyncValues(items);\n            _e.label = 4;\n          case 4:\n            return [4 /*yield*/, items_2.next()];\n          case 5:\n            if (!(items_2_1 = _e.sent(), !items_2_1.done)) return [3 /*break*/, 8];\n            item = items_2_1.value;\n            if (!item) return [3 /*break*/, 7];\n            if (!(typeof item === 'object')) return [3 /*break*/, 7];\n            keyValuesPath = this.getIndexKeyValuesPath(item);\n            return [4 /*yield*/, this.db.delete(keyValuesPath, storeName)];\n          case 6:\n            _e.sent();\n            _e.label = 7;\n          case 7:\n            return [3 /*break*/, 4];\n          case 8:\n            return [3 /*break*/, 15];\n          case 9:\n            e_4_1 = _e.sent();\n            e_4 = {\n              error: e_4_1\n            };\n            return [3 /*break*/, 15];\n          case 10:\n            _e.trys.push([10,, 13, 14]);\n            if (!(items_2_1 && !items_2_1.done && (_b = items_2.return))) return [3 /*break*/, 12];\n            return [4 /*yield*/, _b.call(items_2)];\n          case 11:\n            _e.sent();\n            _e.label = 12;\n          case 12:\n            return [3 /*break*/, 14];\n          case 13:\n            if (e_4) throw e_4.error;\n            return [7 /*endfinally*/];\n          case 14:\n            return [7 /*endfinally*/];\n          case 15:\n            return [3 /*break*/, 1];\n          case 16:\n            return [3 /*break*/, 23];\n          case 17:\n            e_3_1 = _e.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3 /*break*/, 23];\n          case 18:\n            _e.trys.push([18,, 21, 22]);\n            if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 20];\n            return [4 /*yield*/, _a.call(_c)];\n          case 19:\n            _e.sent();\n            _e.label = 20;\n          case 20:\n            return [3 /*break*/, 22];\n          case 21:\n            if (e_3) throw e_3.error;\n            return [7 /*endfinally*/];\n          case 22:\n            return [7 /*endfinally*/];\n          case 23:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Gets related Has One record for `model`\n   *\n   * @param model\n   * @param srcModel\n   * @param namespace\n   * @param rel\n   * @returns\n   */\n  AsyncStorageAdapter.prototype.getHasOneChild = function (model, srcModel, namespace, rel) {\n    return __awaiter(this, void 0, void 0, function () {\n      var hasOneIndex, modelName, targetNames, associatedWith, storeName, index, hasConnectedModelFields, keyValuesPath, values, isUnidirectionalConnection, allRecords, recordToDelete;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            modelName = rel.modelName, targetNames = rel.targetNames, associatedWith = rel.associatedWith;\n            storeName = getStorename(namespace, modelName);\n            index = getIndex(this.schema.namespaces[namespace].relationships[modelName].relationTypes, srcModel) ||\n            // if we were unable to find an index via relationTypes\n            // i.e. for keyName connections, attempt to find one by the\n            // associatedWith property\n            getIndexFromAssociation(this.schema.namespaces[namespace].relationships[modelName].indexes, rel.associatedWith);\n            if (index) {\n              hasOneIndex = index.split(IDENTIFIER_KEY_SEPARATOR);\n            } else if (associatedWith) {\n              if (Array.isArray(associatedWith)) {\n                hasOneIndex = associatedWith;\n              } else {\n                hasOneIndex = [associatedWith];\n              }\n            }\n            hasConnectedModelFields = targetNames.every(function (targetName) {\n              return model.hasOwnProperty(targetName);\n            });\n            keyValuesPath = this.getIndexKeyValuesPath(model);\n            isUnidirectionalConnection = hasOneIndex === associatedWith;\n            if (hasConnectedModelFields && isUnidirectionalConnection) {\n              // Values will be that of the child model\n              values = targetNames.filter(function (targetName) {\n                var _a;\n                return (_a = model[targetName]) !== null && _a !== void 0 ? _a : false;\n              }).map(function (targetName) {\n                return model[targetName];\n              });\n            } else {\n              // values will be that of the parent model\n              values = keyValuesPath.split(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n            }\n            if (values.length === 0) return [2 /*return*/];\n            return [4 /*yield*/, this.db.getAll(storeName)];\n          case 1:\n            allRecords = _a.sent();\n            // values === targetNames\n            if (hasConnectedModelFields) {\n              /**\n               * Retrieve record by finding the record where all\n               * targetNames are present on the connected model.\n               *\n               */\n              recordToDelete = allRecords.find(function (childItem) {\n                return hasOneIndex.every(function (index) {\n                  return values.includes(childItem[index]);\n                });\n              });\n            } else {\n              // values === keyValuePath\n              recordToDelete = allRecords.find(function (childItem) {\n                return childItem[hasOneIndex] === values;\n              });\n            }\n            return [2 /*return*/, recordToDelete];\n        }\n      });\n    });\n  };\n  /**\n   * Backwards compatability for pre-CPK codegen\n   * TODO - deprecate this in v6; will need to re-gen MIPR for older unit\n   * tests that hit this path\n   */\n  AsyncStorageAdapter.prototype.getHasOneChildLegacy = function (model, srcModel, namespace, rel) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelName, targetName, associatedWith, storeName, index, hasOneIndex, hasOneCustomField, keyValuesPath, value, allRecords, recordToDelete;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            modelName = rel.modelName, targetName = rel.targetName, associatedWith = rel.associatedWith;\n            storeName = getStorename(namespace, modelName);\n            index = getIndex(this.schema.namespaces[namespace].relationships[modelName].relationTypes, srcModel) ||\n            // if we were unable to find an index via relationTypes\n            // i.e. for keyName connections, attempt to find one by the\n            // associatedWith property\n            getIndexFromAssociation(this.schema.namespaces[namespace].relationships[modelName].indexes, rel.associatedWith);\n            hasOneIndex = index || associatedWith;\n            hasOneCustomField = targetName in model;\n            keyValuesPath = this.getIndexKeyValuesPath(model);\n            value = hasOneCustomField ? model[targetName] : keyValuesPath;\n            if (!value) return [2 /*return*/];\n            return [4 /*yield*/, this.db.getAll(storeName)];\n          case 1:\n            allRecords = _a.sent();\n            recordToDelete = allRecords.find(function (childItem) {\n              return childItem[hasOneIndex] === value;\n            });\n            return [2 /*return*/, recordToDelete];\n        }\n      });\n    });\n  };\n  /**\n   *  Gets related Has Many records by given `storeName`, `index`, and `keyValues`\n   *\n   * @param storeName\n   * @param index\n   * @param keyValues\n   * @returns\n   */\n  AsyncStorageAdapter.prototype.getHasManyChildren = function (storeName, index, keyValues) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allRecords, indices, childRecords;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.db.getAll(storeName)];\n          case 1:\n            allRecords = _a.sent();\n            indices = index.split(IDENTIFIER_KEY_SEPARATOR);\n            childRecords = allRecords.filter(function (childItem) {\n              return indices.every(function (index) {\n                return keyValues.includes(childItem[index]);\n              });\n            });\n            return [2 /*return*/, childRecords];\n        }\n      });\n    });\n  };\n  //#region platform-specific helper methods\n  /**\n   * Retrieves concatenated primary key values from a model\n   *\n   * @param model\n   * @returns\n   */\n  AsyncStorageAdapter.prototype.getIndexKeyValuesPath = function (model) {\n    return this.getIndexKeyValuesFromModel(model).join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n  };\n  return AsyncStorageAdapter;\n}(StorageAdapterBase);\nexport { AsyncStorageAdapter };\nexport default new AsyncStorageAdapter();","map":{"version":3,"names":["AsyncStorageDatabase","OpType","QueryOne","DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR","getIndex","getIndexFromAssociation","traverseModel","validatePredicate","inMemoryPagination","keysEqual","getStorename","getIndexKeys","IDENTIFIER_KEY_SEPARATOR","StorageAdapterBase","AsyncStorageAdapter","_super","__extends","prototype","preSetUpChecks","preOpCheck","initDb","db","init","_a","sent","clear","undefined","initPromise","batchSave","modelConstructor","items","length","modelName","name","namespaceName","namespaceResolver","storeName","keys","schema","namespaces","batch","item","model","this_1","modelInstanceCreator","connectedModels","getModelConstructorByModelName","keyValuesPath","getIndexKeyValuesPath","instance","find","push","items_1","__values","items_1_1","next","done","value","_b","_get","keyArr","itemKeyValuesPath","join","get","save","condition","saveMetadata","connectionStoreNames","modelKeyValues","fromDB","_c","validateSaveCondition","result","connectionStoreNames_1","__asyncValues","resItem","connectionStoreNames_1_1","storeName_1","itemKeyValues","map","key","fromDB_1","opType","UPDATE","INSERT","query","predicate","pagination","queryMetadata","queryByKey","predicates","hasSort","hasPagination","__awaiter","_this","keyValues","getByKey","record","filterOnPredicate","filtered","getAll","all","records","load","keyValuePath","predicateObjs","type","filter","m","queryOne","firstOrLast","FIRST","getStorenameForModel","getOne","deleteItem","deleteQueue","_d","items_2","items_2_1","delete","_e","getHasOneChild","srcModel","namespace","rel","targetNames","associatedWith","index","relationships","relationTypes","indexes","hasOneIndex","split","Array","isArray","hasConnectedModelFields","every","targetName","hasOwnProperty","isUnidirectionalConnection","values","allRecords","recordToDelete","childItem","includes","getHasOneChildLegacy","hasOneCustomField","getHasManyChildren","indices","childRecords","getIndexKeyValuesFromModel"],"sources":["/Users/macbook/Documents/projet ipssi/temp-repo-chatbot/frontend/node_modules/@aws-amplify/datastore/src/storage/adapter/AsyncStorageAdapter.ts"],"sourcesContent":["import AsyncStorageDatabase from './AsyncStorageDatabase';\nimport {\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tOpType,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicatesGroup,\n\tQueryOne,\n\tRelationType,\n} from '../../types';\nimport {\n\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR,\n\tgetIndex,\n\tgetIndexFromAssociation,\n\ttraverseModel,\n\tvalidatePredicate,\n\tinMemoryPagination,\n\tNAMESPACES,\n\tkeysEqual,\n\tgetStorename,\n\tgetIndexKeys,\n\tIDENTIFIER_KEY_SEPARATOR,\n} from '../../util';\nimport { StorageAdapterBase } from './StorageAdapterBase';\n\nexport class AsyncStorageAdapter extends StorageAdapterBase {\n\tprotected db!: AsyncStorageDatabase;\n\n\t// no-ops for this adapter\n\tprotected async preSetUpChecks() {}\n\tprotected async preOpCheck() {}\n\n\t/**\n\t * Open AsyncStorage database\n\t * Create new DB if one doesn't exist\n\t *\n\t * Called by `StorageAdapterBase.setUp()`\n\t *\n\t * @returns AsyncStorageDatabase instance\n\t */\n\tprotected async initDb(): Promise<AsyncStorageDatabase> {\n\t\tconst db = new AsyncStorageDatabase();\n\t\tawait db.init();\n\t\treturn db;\n\t}\n\n\tasync clear(): Promise<void> {\n\t\tawait this.db.clear();\n\n\t\tthis.db = undefined!;\n\t\tthis.initPromise = undefined!;\n\t}\n\n\tasync batchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<any>,\n\t\titems: ModelInstanceMetadata[]\n\t): Promise<[T, OpType][]> {\n\t\tif (items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst modelName = modelConstructor.name;\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\t\tconst storeName = getStorename(namespaceName, modelName);\n\t\tconst keys = getIndexKeys(this.schema.namespaces[namespaceName], modelName);\n\t\tconst batch: ModelInstanceMetadata[] = [];\n\n\t\tfor (const item of items) {\n\t\t\tconst model = this.modelInstanceCreator(modelConstructor, item);\n\n\t\t\tconst connectedModels = traverseModel(\n\t\t\t\tmodelName,\n\t\t\t\tmodel,\n\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\tthis.getModelConstructorByModelName\n\t\t\t);\n\n\t\t\tconst keyValuesPath = this.getIndexKeyValuesPath(model);\n\n\t\t\tconst { instance } = connectedModels.find(({ instance }) => {\n\t\t\t\tconst instanceKeyValuesPath = this.getIndexKeyValuesPath(instance);\n\t\t\t\treturn keysEqual([instanceKeyValuesPath], [keyValuesPath]);\n\t\t\t})!;\n\n\t\t\tbatch.push(instance);\n\t\t}\n\n\t\treturn await this.db.batchSave(storeName, batch, keys);\n\t}\n\n\tprotected async _get<T>(storeName: string, keyArr: string[]): Promise<T> {\n\t\tconst itemKeyValuesPath: string = keyArr.join(\n\t\t\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR\n\t\t);\n\n\t\treturn <T>await this.db.get(itemKeyValuesPath, storeName);\n\t}\n\n\tasync save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>\n\t): Promise<[T, OpType.INSERT | OpType.UPDATE][]> {\n\t\tconst { storeName, connectionStoreNames, modelKeyValues } =\n\t\t\tthis.saveMetadata(model);\n\n\t\tconst fromDB = await this._get(storeName, modelKeyValues);\n\n\t\tthis.validateSaveCondition(condition, fromDB);\n\n\t\tconst result: [T, OpType.INSERT | OpType.UPDATE][] = [];\n\t\tfor await (const resItem of connectionStoreNames) {\n\t\t\tconst { storeName, item, instance, keys } = resItem;\n\n\t\t\tconst itemKeyValues: string[] = keys.map(key => item[key]);\n\n\t\t\tconst fromDB = <T>await this._get(storeName, itemKeyValues);\n\t\t\tconst opType: OpType = fromDB ? OpType.UPDATE : OpType.INSERT;\n\n\t\t\tif (\n\t\t\t\tkeysEqual(itemKeyValues, modelKeyValues) ||\n\t\t\t\topType === OpType.INSERT\n\t\t\t) {\n\t\t\t\tawait this.db.save(\n\t\t\t\t\titem,\n\t\t\t\t\tstoreName,\n\t\t\t\t\tkeys,\n\t\t\t\t\titemKeyValues.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR)\n\t\t\t\t);\n\n\t\t\t\tresult.push([instance, opType]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tasync query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]> {\n\t\tconst {\n\t\t\tstoreName,\n\t\t\tnamespaceName,\n\t\t\tqueryByKey,\n\t\t\tpredicates,\n\t\t\thasSort,\n\t\t\thasPagination,\n\t\t} = this.queryMetadata(modelConstructor, predicate, pagination);\n\n\t\tconst records: T[] = (await (async () => {\n\t\t\tif (queryByKey) {\n\t\t\t\tconst keyValues = queryByKey.join(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n\t\t\t\tconst record = await this.getByKey(storeName, keyValues);\n\t\t\t\treturn record ? [record] : [];\n\t\t\t}\n\n\t\t\tif (predicates) {\n\t\t\t\tconst filtered = await this.filterOnPredicate(storeName, predicates);\n\t\t\t\treturn this.inMemoryPagination(filtered, pagination);\n\t\t\t}\n\n\t\t\tif (hasSort || hasPagination) {\n\t\t\t\tconst all = await this.getAll(storeName);\n\t\t\t\treturn this.inMemoryPagination(all, pagination);\n\t\t\t}\n\n\t\t\treturn this.getAll(storeName);\n\t\t})()) as T[];\n\n\t\treturn await this.load(namespaceName, modelConstructor.name, records);\n\t}\n\n\tprivate async getByKey<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tkeyValuePath: string\n\t): Promise<T> {\n\t\treturn <T>await this.db.get(keyValuePath, storeName);\n\t}\n\n\tprivate async getAll<T extends PersistentModel>(\n\t\tstoreName: string\n\t): Promise<T[]> {\n\t\treturn await this.db.getAll(storeName);\n\t}\n\n\tprivate async filterOnPredicate<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tpredicates: PredicatesGroup<T>\n\t) {\n\t\tconst { predicates: predicateObjs, type } = predicates;\n\n\t\tconst all = <T[]>await this.getAll(storeName);\n\n\t\tconst filtered = predicateObjs\n\t\t\t? all.filter(m => validatePredicate(m, type, predicateObjs))\n\t\t\t: all;\n\n\t\treturn filtered;\n\t}\n\n\tprivate inMemoryPagination<T extends PersistentModel>(\n\t\trecords: T[],\n\t\tpagination?: PaginationInput<T>\n\t): T[] {\n\t\treturn inMemoryPagination(records, pagination);\n\t}\n\n\tasync queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne = QueryOne.FIRST\n\t): Promise<T | undefined> {\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst result = <T>await this.db.getOne(firstOrLast, storeName);\n\n\t\treturn result && this.modelInstanceCreator(modelConstructor, result);\n\t}\n\n\tprotected async deleteItem<T extends PersistentModel>(\n\t\tdeleteQueue?: { storeName: string; items: T[] | IDBValidKey[] }[]\n\t) {\n\t\tfor await (const deleteItem of deleteQueue!) {\n\t\t\tconst { storeName, items } = deleteItem;\n\n\t\t\tfor await (const item of items) {\n\t\t\t\tif (item) {\n\t\t\t\t\tif (typeof item === 'object') {\n\t\t\t\t\t\tconst keyValuesPath: string = this.getIndexKeyValuesPath(item as T);\n\t\t\t\t\t\tawait this.db.delete(keyValuesPath, storeName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets related Has One record for `model`\n\t *\n\t * @param model\n\t * @param srcModel\n\t * @param namespace\n\t * @param rel\n\t * @returns\n\t */\n\tprotected async getHasOneChild<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tsrcModel: string,\n\t\tnamespace: NAMESPACES,\n\t\trel: RelationType\n\t) {\n\t\tlet hasOneIndex;\n\t\tconst { modelName, targetNames, associatedWith } = rel;\n\t\tconst storeName = getStorename(namespace, modelName);\n\t\tconst index: string | undefined =\n\t\t\tgetIndex(\n\t\t\t\tthis.schema.namespaces[namespace].relationships![modelName]\n\t\t\t\t\t.relationTypes,\n\t\t\t\tsrcModel\n\t\t\t) ||\n\t\t\t// if we were unable to find an index via relationTypes\n\t\t\t// i.e. for keyName connections, attempt to find one by the\n\t\t\t// associatedWith property\n\t\t\tgetIndexFromAssociation(\n\t\t\t\tthis.schema.namespaces[namespace].relationships![modelName].indexes,\n\t\t\t\trel.associatedWith!\n\t\t\t);\n\n\t\tif (index) {\n\t\t\thasOneIndex = index.split(IDENTIFIER_KEY_SEPARATOR);\n\t\t} else if (associatedWith) {\n\t\t\tif (Array.isArray(associatedWith)) {\n\t\t\t\thasOneIndex = associatedWith;\n\t\t\t} else {\n\t\t\t\thasOneIndex = [associatedWith];\n\t\t\t}\n\t\t}\n\n\t\t// iterate over targetNames array and see if each key is present in model object\n\t\t// targetNames here being the keys for the CHILD model\n\t\tconst hasConnectedModelFields = targetNames!.every(targetName =>\n\t\t\tmodel.hasOwnProperty(targetName)\n\t\t);\n\n\t\t// PK / Composite key for the parent model\n\t\tconst keyValuesPath: string = this.getIndexKeyValuesPath(model);\n\n\t\tlet values;\n\n\t\tconst isUnidirectionalConnection = hasOneIndex === associatedWith;\n\n\t\tif (hasConnectedModelFields && isUnidirectionalConnection) {\n\t\t\t// Values will be that of the child model\n\t\t\tvalues = targetNames!\n\t\t\t\t.filter(targetName => model[targetName] ?? false)\n\t\t\t\t.map(targetName => model[targetName]);\n\t\t} else {\n\t\t\t// values will be that of the parent model\n\t\t\tvalues = keyValuesPath.split(DEFAULT_PRIMARY_KEY_VALUE_SEPARATOR);\n\t\t}\n\n\t\tif (values.length === 0) return;\n\n\t\tconst allRecords = await this.db.getAll(storeName);\n\n\t\tlet recordToDelete;\n\n\t\t// values === targetNames\n\t\tif (hasConnectedModelFields) {\n\t\t\t/**\n\t\t\t * Retrieve record by finding the record where all\n\t\t\t * targetNames are present on the connected model.\n\t\t\t *\n\t\t\t */\n\n\t\t\trecordToDelete = allRecords.find(childItem =>\n\t\t\t\thasOneIndex.every(index => values.includes(childItem[index]))\n\t\t\t);\n\t\t} else {\n\t\t\t// values === keyValuePath\n\t\t\trecordToDelete = allRecords.find(\n\t\t\t\tchildItem => childItem[hasOneIndex] === values\n\t\t\t) as T[];\n\t\t}\n\n\t\treturn recordToDelete;\n\t}\n\n\t/**\n\t * Backwards compatability for pre-CPK codegen\n\t * TODO - deprecate this in v6; will need to re-gen MIPR for older unit\n\t * tests that hit this path\n\t */\n\tprotected async getHasOneChildLegacy<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tsrcModel: string,\n\t\tnamespace: NAMESPACES,\n\t\trel: RelationType\n\t) {\n\t\tconst { modelName, targetName, associatedWith } = rel;\n\t\tconst storeName = getStorename(namespace, modelName);\n\t\tconst index: string | undefined =\n\t\t\tgetIndex(\n\t\t\t\tthis.schema.namespaces[namespace].relationships![modelName]\n\t\t\t\t\t.relationTypes,\n\t\t\t\tsrcModel\n\t\t\t) ||\n\t\t\t// if we were unable to find an index via relationTypes\n\t\t\t// i.e. for keyName connections, attempt to find one by the\n\t\t\t// associatedWith property\n\t\t\tgetIndexFromAssociation(\n\t\t\t\tthis.schema.namespaces[namespace].relationships![modelName].indexes,\n\t\t\t\trel.associatedWith!\n\t\t\t);\n\t\tconst hasOneIndex = index || associatedWith;\n\t\tconst hasOneCustomField = targetName! in model;\n\t\tconst keyValuesPath: string = this.getIndexKeyValuesPath(model);\n\t\tconst value = hasOneCustomField ? model[targetName!] : keyValuesPath;\n\n\t\tif (!value) return;\n\n\t\tconst allRecords = await this.db.getAll(storeName);\n\n\t\tconst recordToDelete = allRecords.find(\n\t\t\tchildItem => childItem[hasOneIndex as string] === value\n\t\t) as T;\n\n\t\treturn recordToDelete;\n\t}\n\n\t/**\n\t *  Gets related Has Many records by given `storeName`, `index`, and `keyValues`\n\t *\n\t * @param storeName\n\t * @param index\n\t * @param keyValues\n\t * @returns\n\t */\n\tprotected async getHasManyChildren<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tindex: string,\n\t\tkeyValues: string[]\n\t): Promise<T[]> {\n\t\tconst allRecords = await this.db.getAll(storeName);\n\t\tconst indices = index!.split(IDENTIFIER_KEY_SEPARATOR);\n\n\t\tconst childRecords = allRecords.filter(childItem =>\n\t\t\tindices.every(index => keyValues.includes(childItem[index]))\n\t\t) as T[];\n\n\t\treturn childRecords;\n\t}\n\n\t//#region platform-specific helper methods\n\n\t/**\n\t * Retrieves concatenated primary key values from a model\n\t *\n\t * @param model\n\t * @returns\n\t */\n\tprivate getIndexKeyValuesPath<T extends PersistentModel>(model: T): string {\n\t\treturn this.getIndexKeyValuesFromModel(model).join(\n\t\t\tDEFAULT_PRIMARY_KEY_VALUE_SEPARATOR\n\t\t);\n\t}\n\n\t//#endregion\n}\n\nexport default new AsyncStorageAdapter();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}