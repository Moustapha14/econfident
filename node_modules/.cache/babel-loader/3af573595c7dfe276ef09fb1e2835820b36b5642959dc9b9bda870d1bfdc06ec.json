{"ast":null,"code":"import { __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { ModelPredicateCreator } from '../../predicates';\nimport { isPredicateObj } from '../../types';\nimport { getStorename, getIndexKeys, extractPrimaryKeyValues, traverseModel, validatePredicate, getIndex, getIndexFromAssociation, isModelConstructor } from '../../util';\nvar logger = new Logger('DataStore');\nvar DB_NAME = 'amplify-datastore';\nvar StorageAdapterBase = /** @class */function () {\n  function StorageAdapterBase() {\n    this.dbName = DB_NAME;\n  }\n  /**\n   * Initializes local DB\n   *\n   * @param theSchema\n   * @param namespaceResolver\n   * @param modelInstanceCreator\n   * @param getModelConstructorByModelName\n   * @param sessionId\n   */\n  StorageAdapterBase.prototype.setUp = function (theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName, sessionId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, error_1;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.preSetUpChecks()];\n          case 1:\n            _b.sent();\n            if (!!this.initPromise) return [3 /*break*/, 2];\n            this.initPromise = new Promise(function (res, rej) {\n              _this.resolve = res;\n              _this.reject = rej;\n            });\n            return [3 /*break*/, 4];\n          case 2:\n            return [4 /*yield*/, this.initPromise];\n          case 3:\n            _b.sent();\n            return [2 /*return*/];\n          case 4:\n            if (sessionId) {\n              this.dbName = DB_NAME + \"-\" + sessionId;\n            }\n            this.schema = theSchema;\n            this.namespaceResolver = namespaceResolver;\n            this.modelInstanceCreator = modelInstanceCreator;\n            this.getModelConstructorByModelName = getModelConstructorByModelName;\n            _b.label = 5;\n          case 5:\n            _b.trys.push([5, 8,, 9]);\n            if (!!this.db) return [3 /*break*/, 7];\n            _a = this;\n            return [4 /*yield*/, this.initDb()];\n          case 6:\n            _a.db = _b.sent();\n            this.resolve();\n            _b.label = 7;\n          case 7:\n            return [3 /*break*/, 9];\n          case 8:\n            error_1 = _b.sent();\n            this.reject(error_1);\n            return [3 /*break*/, 9];\n          case 9:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * @param modelConstructor\n   * @returns local DB table name\n   */\n  StorageAdapterBase.prototype.getStorenameForModel = function (modelConstructor) {\n    var namespace = this.namespaceResolver(modelConstructor);\n    var modelName = modelConstructor.name;\n    return getStorename(namespace, modelName);\n  };\n  /**\n   *\n   * @param model - instantiated model record\n   * @returns the record's primary key values\n   */\n  StorageAdapterBase.prototype.getIndexKeyValuesFromModel = function (model) {\n    var modelConstructor = Object.getPrototypeOf(model).constructor;\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var keys = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n    return extractPrimaryKeyValues(model, keys);\n  };\n  /**\n   * Common metadata for `save` operation\n   * used by individual storage adapters\n   *\n   * @param model\n   */\n  StorageAdapterBase.prototype.saveMetadata = function (model) {\n    var _this = this;\n    var modelConstructor = Object.getPrototypeOf(model).constructor;\n    var storeName = this.getStorenameForModel(modelConstructor);\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[namespaceName], this.modelInstanceCreator, this.getModelConstructorByModelName);\n    var set = new Set();\n    var connectionStoreNames = Object.values(connectedModels).map(function (_a) {\n      var modelName = _a.modelName,\n        item = _a.item,\n        instance = _a.instance;\n      var storeName = getStorename(namespaceName, modelName);\n      set.add(storeName);\n      var keys = getIndexKeys(_this.schema.namespaces[namespaceName], modelName);\n      return {\n        storeName: storeName,\n        item: item,\n        instance: instance,\n        keys: keys\n      };\n    });\n    var modelKeyValues = this.getIndexKeyValuesFromModel(model);\n    return {\n      storeName: storeName,\n      set: set,\n      connectionStoreNames: connectionStoreNames,\n      modelKeyValues: modelKeyValues\n    };\n  };\n  /**\n   * Enforces conditional save. Throws if condition is not met.\n   * used by individual storage adapters\n   *\n   * @param model\n   */\n  StorageAdapterBase.prototype.validateSaveCondition = function (condition, fromDB) {\n    if (!(condition && fromDB)) {\n      return;\n    }\n    var predicates = ModelPredicateCreator.getPredicates(condition);\n    var _a = predicates,\n      predicateObjs = _a.predicates,\n      type = _a.type;\n    var isValid = validatePredicate(fromDB, type, predicateObjs);\n    if (!isValid) {\n      var msg = 'Conditional update failed';\n      logger.error(msg, {\n        model: fromDB,\n        condition: predicateObjs\n      });\n      throw new Error(msg);\n    }\n  };\n  /**\n   * Instantiate models from POJO records returned from the database\n   *\n   * @param namespaceName - string model namespace\n   * @param srcModelName - string model name\n   * @param records - array of uninstantiated records\n   * @returns\n   */\n  StorageAdapterBase.prototype.load = function (namespaceName, srcModelName, records) {\n    return __awaiter(this, void 0, void 0, function () {\n      var namespace, relations, connectionStoreNames, modelConstructor;\n      var _this = this;\n      return __generator(this, function (_a) {\n        namespace = this.schema.namespaces[namespaceName];\n        relations = namespace.relationships[srcModelName].relationTypes;\n        connectionStoreNames = relations.map(function (_a) {\n          var modelName = _a.modelName;\n          return getStorename(namespaceName, modelName);\n        });\n        modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);\n        if (connectionStoreNames.length === 0) {\n          return [2 /*return*/, records.map(function (record) {\n            return _this.modelInstanceCreator(modelConstructor, record);\n          })];\n        }\n        return [2 /*return*/, records.map(function (record) {\n          return _this.modelInstanceCreator(modelConstructor, record);\n        })];\n      });\n    });\n  };\n  /**\n   * Extracts operands from a predicate group into an array of key values\n   * Used in the query method\n   *\n   * @param predicates - predicate group\n   * @param keyPath - string array of key names ['id', 'sortKey']\n   * @returns string[] of key values\n   *\n   * @example\n   * ```js\n   * { and:[{ id: { eq: 'abc' }}, { sortKey: { eq: 'def' }}] }\n   * ```\n   * Becomes\n   * ```\n   * ['abc', 'def']\n   * ```\n   */\n  StorageAdapterBase.prototype.keyValueFromPredicate = function (predicates, keyPath) {\n    var e_1, _a;\n    var predicateObjs = predicates.predicates;\n    if (predicateObjs.length !== keyPath.length) {\n      return;\n    }\n    var keyValues = [];\n    var _loop_1 = function (key) {\n      var predicateObj = predicateObjs.find(function (p) {\n        // it's a relevant predicate object only if it's an equality\n        // operation for a key field from the key:\n        return isPredicateObj(p) && p.field === key && p.operator === 'eq' && p.operand !== null && p.operand !== undefined;\n      });\n      predicateObj && keyValues.push(predicateObj.operand);\n    };\n    try {\n      for (var keyPath_1 = __values(keyPath), keyPath_1_1 = keyPath_1.next(); !keyPath_1_1.done; keyPath_1_1 = keyPath_1.next()) {\n        var key = keyPath_1_1.value;\n        _loop_1(key);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (keyPath_1_1 && !keyPath_1_1.done && (_a = keyPath_1.return)) _a.call(keyPath_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return keyValues.length === keyPath.length ? keyValues : undefined;\n  };\n  /**\n   * Common metadata for `query` operation\n   * used by individual storage adapters\n   *\n   * @param modelConstructor\n   * @param predicate\n   * @param pagination\n   */\n  StorageAdapterBase.prototype.queryMetadata = function (modelConstructor, predicate, pagination) {\n    var storeName = this.getStorenameForModel(modelConstructor);\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var predicates = predicate && ModelPredicateCreator.getPredicates(predicate);\n    var keyPath = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n    var queryByKey = predicates && this.keyValueFromPredicate(predicates, keyPath);\n    var hasSort = pagination && pagination.sort;\n    var hasPagination = pagination && pagination.limit;\n    return {\n      storeName: storeName,\n      namespaceName: namespaceName,\n      queryByKey: queryByKey,\n      predicates: predicates,\n      hasSort: hasSort,\n      hasPagination: hasPagination\n    };\n  };\n  /**\n   * Delete record\n   * Cascades to related records (for Has One and Has Many relationships)\n   *\n   * @param modelOrModelConstructor\n   * @param condition\n   * @returns\n   */\n  StorageAdapterBase.prototype.delete = function (modelOrModelConstructor, condition) {\n    return __awaiter(this, void 0, void 0, function () {\n      var deleteQueue, modelConstructor, namespace, models, relations, deletedModels, deletedModels, model, modelConstructor, namespaceName, storeName, keyValues, fromDB, msg, predicates, _a, predicateObjs, type, isValid, msg, relations, relations, deletedModels;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.preOpCheck()];\n          case 1:\n            _b.sent();\n            deleteQueue = [];\n            if (!isModelConstructor(modelOrModelConstructor)) return [3 /*break*/, 9];\n            modelConstructor = modelOrModelConstructor;\n            namespace = this.namespaceResolver(modelConstructor);\n            return [4 /*yield*/, this.query(modelConstructor, condition)];\n          case 2:\n            models = _b.sent();\n            relations = this.schema.namespaces[namespace].relationships[modelConstructor.name].relationTypes;\n            if (!(condition !== undefined)) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.deleteTraverse(relations, models, modelConstructor.name, namespace, deleteQueue)];\n          case 3:\n            _b.sent();\n            return [4 /*yield*/, this.deleteItem(deleteQueue)];\n          case 4:\n            _b.sent();\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2 /*return*/, [models, deletedModels]];\n          case 5:\n            return [4 /*yield*/, this.deleteTraverse(relations, models, modelConstructor.name, namespace, deleteQueue)];\n          case 6:\n            _b.sent();\n            return [4 /*yield*/, this.deleteItem(deleteQueue)];\n          case 7:\n            _b.sent();\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2 /*return*/, [models, deletedModels]];\n          case 8:\n            return [3 /*break*/, 16];\n          case 9:\n            model = modelOrModelConstructor;\n            modelConstructor = Object.getPrototypeOf(model).constructor;\n            namespaceName = this.namespaceResolver(modelConstructor);\n            storeName = this.getStorenameForModel(modelConstructor);\n            if (!condition) return [3 /*break*/, 12];\n            keyValues = this.getIndexKeyValuesFromModel(model);\n            return [4 /*yield*/, this._get(storeName, keyValues)];\n          case 10:\n            fromDB = _b.sent();\n            if (fromDB === undefined) {\n              msg = 'Model instance not found in storage';\n              logger.warn(msg, {\n                model: model\n              });\n              return [2 /*return*/, [[model], []]];\n            }\n            predicates = ModelPredicateCreator.getPredicates(condition);\n            _a = predicates, predicateObjs = _a.predicates, type = _a.type;\n            isValid = validatePredicate(fromDB, type, predicateObjs);\n            if (!isValid) {\n              msg = 'Conditional update failed';\n              logger.error(msg, {\n                model: fromDB,\n                condition: predicateObjs\n              });\n              throw new Error(msg);\n            }\n            relations = this.schema.namespaces[namespaceName].relationships[modelConstructor.name].relationTypes;\n            return [4 /*yield*/, this.deleteTraverse(relations, [model], modelConstructor.name, namespaceName, deleteQueue)];\n          case 11:\n            _b.sent();\n            return [3 /*break*/, 14];\n          case 12:\n            relations = this.schema.namespaces[namespaceName].relationships[modelConstructor.name].relationTypes;\n            return [4 /*yield*/, this.deleteTraverse(relations, [model], modelConstructor.name, namespaceName, deleteQueue)];\n          case 13:\n            _b.sent();\n            _b.label = 14;\n          case 14:\n            return [4 /*yield*/, this.deleteItem(deleteQueue)];\n          case 15:\n            _b.sent();\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2 /*return*/, [[model], deletedModels]];\n          case 16:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Recursively traverse relationship graph and add\n   * all Has One and Has Many relations to `deleteQueue` param\n   *\n   * Actual deletion of records added to `deleteQueue` occurs in the `delete` method\n   *\n   * @param relations\n   * @param models\n   * @param srcModel\n   * @param namespace\n   * @param deleteQueue\n   */\n  StorageAdapterBase.prototype.deleteTraverse = function (relations, models, srcModel, namespace, deleteQueue) {\n    var relations_1, relations_1_1, models_1, models_1_1;\n    var e_2, _a, e_3, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var rel, modelName, relationType, targetNames, associatedWith, storeName, index, model, childRecords, _c, childRecord, keyValues, records, childModels, e_3_1, e_2_1;\n      var _this = this;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            _d.trys.push([0, 28, 29, 34]);\n            relations_1 = __asyncValues(relations);\n            _d.label = 1;\n          case 1:\n            return [4 /*yield*/, relations_1.next()];\n          case 2:\n            if (!(relations_1_1 = _d.sent(), !relations_1_1.done)) return [3 /*break*/, 27];\n            rel = relations_1_1.value;\n            modelName = rel.modelName, relationType = rel.relationType, targetNames = rel.targetNames, associatedWith = rel.associatedWith;\n            storeName = getStorename(namespace, modelName);\n            index = getIndex(this.schema.namespaces[namespace].relationships[modelName].relationTypes, srcModel) ||\n            // if we were unable to find an index via relationTypes\n            // i.e. for keyName connections, attempt to find one by the\n            // associatedWith property\n            getIndexFromAssociation(this.schema.namespaces[namespace].relationships[modelName].indexes, associatedWith);\n            _d.label = 3;\n          case 3:\n            _d.trys.push([3, 20, 21, 26]);\n            models_1 = __asyncValues(models);\n            _d.label = 4;\n          case 4:\n            return [4 /*yield*/, models_1.next()];\n          case 5:\n            if (!(models_1_1 = _d.sent(), !models_1_1.done)) return [3 /*break*/, 19];\n            model = models_1_1.value;\n            childRecords = [];\n            _c = relationType;\n            switch (_c) {\n              case 'HAS_ONE':\n                return [3 /*break*/, 6];\n              case 'HAS_MANY':\n                return [3 /*break*/, 11];\n              case 'BELONGS_TO':\n                return [3 /*break*/, 13];\n            }\n            return [3 /*break*/, 14];\n          case 6:\n            childRecord = void 0;\n            if (!(targetNames === null || targetNames === void 0 ? void 0 : targetNames.length)) return [3 /*break*/, 8];\n            return [4 /*yield*/, this.getHasOneChild(model, srcModel, namespace, rel)];\n          case 7:\n            childRecord = _d.sent();\n            return [3 /*break*/, 10];\n          case 8:\n            return [4 /*yield*/, this.getHasOneChildLegacy(model, srcModel, namespace, rel)];\n          case 9:\n            childRecord = _d.sent();\n            _d.label = 10;\n          case 10:\n            if (childRecord) {\n              childRecords.push(childRecord);\n            }\n            return [3 /*break*/, 15];\n          case 11:\n            keyValues = this.getIndexKeyValuesFromModel(model);\n            return [4 /*yield*/, this.getHasManyChildren(storeName, index, keyValues)];\n          case 12:\n            records = _d.sent();\n            if (records === null || records === void 0 ? void 0 : records.length) {\n              childRecords.push.apply(childRecords, __spread(records));\n            }\n            return [3 /*break*/, 15];\n          case 13:\n            // Intentionally blank\n            return [3 /*break*/, 15];\n          case 14:\n            throw new Error(\"Invalid relation type \" + relationType);\n          case 15:\n            return [4 /*yield*/, this.load(namespace, modelName, childRecords)];\n          case 16:\n            childModels = _d.sent();\n            return [4 /*yield*/, this.deleteTraverse(this.schema.namespaces[namespace].relationships[modelName].relationTypes, childModels, modelName, namespace, deleteQueue)];\n          case 17:\n            _d.sent();\n            _d.label = 18;\n          case 18:\n            return [3 /*break*/, 4];\n          case 19:\n            return [3 /*break*/, 26];\n          case 20:\n            e_3_1 = _d.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3 /*break*/, 26];\n          case 21:\n            _d.trys.push([21,, 24, 25]);\n            if (!(models_1_1 && !models_1_1.done && (_b = models_1.return))) return [3 /*break*/, 23];\n            return [4 /*yield*/, _b.call(models_1)];\n          case 22:\n            _d.sent();\n            _d.label = 23;\n          case 23:\n            return [3 /*break*/, 25];\n          case 24:\n            if (e_3) throw e_3.error;\n            return [7 /*endfinally*/];\n          case 25:\n            return [7 /*endfinally*/];\n          case 26:\n            return [3 /*break*/, 1];\n          case 27:\n            return [3 /*break*/, 34];\n          case 28:\n            e_2_1 = _d.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3 /*break*/, 34];\n          case 29:\n            _d.trys.push([29,, 32, 33]);\n            if (!(relations_1_1 && !relations_1_1.done && (_a = relations_1.return))) return [3 /*break*/, 31];\n            return [4 /*yield*/, _a.call(relations_1)];\n          case 30:\n            _d.sent();\n            _d.label = 31;\n          case 31:\n            return [3 /*break*/, 33];\n          case 32:\n            if (e_2) throw e_2.error;\n            return [7 /*endfinally*/];\n          case 33:\n            return [7 /*endfinally*/];\n          case 34:\n            deleteQueue.push({\n              storeName: getStorename(namespace, srcModel),\n              items: models.map(function (record) {\n                return _this.modelInstanceCreator(_this.getModelConstructorByModelName(namespace, srcModel), record);\n              })\n            });\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return StorageAdapterBase;\n}();\nexport { StorageAdapterBase };","map":{"version":3,"names":["ConsoleLogger","Logger","ModelPredicateCreator","isPredicateObj","getStorename","getIndexKeys","extractPrimaryKeyValues","traverseModel","validatePredicate","getIndex","getIndexFromAssociation","isModelConstructor","logger","DB_NAME","StorageAdapterBase","dbName","prototype","setUp","theSchema","namespaceResolver","modelInstanceCreator","getModelConstructorByModelName","sessionId","preSetUpChecks","_b","sent","initPromise","Promise","res","rej","_this","resolve","reject","schema","db","_a","initDb","error_1","getStorenameForModel","modelConstructor","namespace","modelName","name","getIndexKeyValuesFromModel","model","Object","getPrototypeOf","constructor","namespaceName","keys","namespaces","saveMetadata","storeName","connectedModels","set","Set","connectionStoreNames","values","map","item","instance","add","modelKeyValues","validateSaveCondition","condition","fromDB","predicates","getPredicates","predicateObjs","type","isValid","msg","error","Error","load","srcModelName","records","relations","relationships","relationTypes","length","record","keyValueFromPredicate","keyPath","keyValues","key","predicateObj","find","p","field","operator","operand","undefined","push","keyPath_1","__values","keyPath_1_1","next","done","value","queryMetadata","predicate","pagination","queryByKey","hasSort","sort","hasPagination","limit","delete","modelOrModelConstructor","preOpCheck","deleteQueue","query","models","deleteTraverse","deleteItem","deletedModels","reduce","acc","items","concat","_get","warn","srcModel","relations_1","__asyncValues","rel","relations_1_1","relationType","targetNames","associatedWith","index","indexes","models_1","models_1_1","childRecords","_c","childRecord","getHasOneChild","_d","getHasOneChildLegacy","getHasManyChildren","apply","__spread","childModels"],"sources":["/Users/macbook/Documents/projet ipssi/temp-repo-chatbot/frontend/node_modules/@aws-amplify/datastore/src/storage/adapter/StorageAdapterBase.ts"],"sourcesContent":["import { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { Adapter } from './index';\nimport { ModelInstanceCreator } from '../../datastore/datastore';\nimport { ModelPredicateCreator } from '../../predicates';\nimport {\n\tInternalSchema,\n\tisPredicateObj,\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tNamespaceResolver,\n\tOpType,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicateObject,\n\tPredicatesGroup,\n\tQueryOne,\n\tRelationType,\n} from '../../types';\nimport {\n\tNAMESPACES,\n\tgetStorename,\n\tgetIndexKeys,\n\textractPrimaryKeyValues,\n\ttraverseModel,\n\tvalidatePredicate,\n\tgetIndex,\n\tgetIndexFromAssociation,\n\tisModelConstructor,\n} from '../../util';\nimport type { IDBPDatabase, IDBPObjectStore } from 'idb';\nimport type AsyncStorageDatabase from './AsyncStorageDatabase';\n\nconst logger = new Logger('DataStore');\nconst DB_NAME = 'amplify-datastore';\n\nexport abstract class StorageAdapterBase implements Adapter {\n\t// Non-null assertions (bang operators) added to most properties to make TS happy.\n\t// For now, we can be reasonably sure they're available when they're needed, because\n\t// the adapter is not used directly outside the library boundary.\n\tprotected schema!: InternalSchema;\n\tprotected namespaceResolver!: NamespaceResolver;\n\tprotected modelInstanceCreator!: ModelInstanceCreator;\n\tprotected getModelConstructorByModelName!: (\n\t\tnamsespaceName: NAMESPACES,\n\t\tmodelName: string\n\t) => PersistentModelConstructor<any>;\n\tprotected initPromise!: Promise<void>;\n\tprotected resolve!: (value?: any) => void;\n\tprotected reject!: (value?: any) => void;\n\tprotected dbName: string = DB_NAME;\n\tprotected abstract db: IDBPDatabase | AsyncStorageDatabase;\n\n\tprotected abstract preSetUpChecks(): Promise<void>;\n\tprotected abstract preOpCheck(): Promise<void>;\n\tprotected abstract initDb(): Promise<IDBPDatabase | AsyncStorageDatabase>;\n\n\t/**\n\t * Initializes local DB\n\t *\n\t * @param theSchema\n\t * @param namespaceResolver\n\t * @param modelInstanceCreator\n\t * @param getModelConstructorByModelName\n\t * @param sessionId\n\t */\n\tpublic async setUp(\n\t\ttheSchema: InternalSchema,\n\t\tnamespaceResolver: NamespaceResolver,\n\t\tmodelInstanceCreator: ModelInstanceCreator,\n\t\tgetModelConstructorByModelName: (\n\t\t\tnamsespaceName: NAMESPACES,\n\t\t\tmodelName: string\n\t\t) => PersistentModelConstructor<any>,\n\t\tsessionId?: string\n\t): Promise<void> {\n\t\tawait this.preSetUpChecks();\n\n\t\tif (!this.initPromise) {\n\t\t\tthis.initPromise = new Promise((res, rej) => {\n\t\t\t\tthis.resolve = res;\n\t\t\t\tthis.reject = rej;\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.initPromise;\n\t\t\treturn;\n\t\t}\n\t\tif (sessionId) {\n\t\t\tthis.dbName = `${DB_NAME}-${sessionId}`;\n\t\t}\n\t\tthis.schema = theSchema;\n\t\tthis.namespaceResolver = namespaceResolver;\n\t\tthis.modelInstanceCreator = modelInstanceCreator;\n\t\tthis.getModelConstructorByModelName = getModelConstructorByModelName;\n\n\t\ttry {\n\t\t\tif (!this.db) {\n\t\t\t\tthis.db = await this.initDb();\n\t\t\t\tthis.resolve();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.reject(error);\n\t\t}\n\t}\n\n\t/*\n\t * Abstract Methods for Adapter interface\n\t * Not enough implementation similarities between the adapters\n\t * to consolidate in the base class\n\t */\n\tpublic abstract clear(): Promise<void>;\n\n\tpublic abstract save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>\n\t);\n\n\tpublic abstract query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]>;\n\n\tpublic abstract queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne\n\t): Promise<T | undefined>;\n\n\tpublic abstract batchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<any>,\n\t\titems: ModelInstanceMetadata[]\n\t): Promise<[T, OpType][]>;\n\n\t/**\n\t * @param modelConstructor\n\t * @returns local DB table name\n\t */\n\tprotected getStorenameForModel(\n\t\tmodelConstructor: PersistentModelConstructor<any>\n\t): string {\n\t\tconst namespace = this.namespaceResolver(modelConstructor);\n\t\tconst { name: modelName } = modelConstructor;\n\n\t\treturn getStorename(namespace, modelName);\n\t}\n\n\t/**\n\t *\n\t * @param model - instantiated model record\n\t * @returns the record's primary key values\n\t */\n\tprotected getIndexKeyValuesFromModel<T extends PersistentModel>(\n\t\tmodel: T\n\t): string[] {\n\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst keys = getIndexKeys(\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tmodelConstructor.name\n\t\t);\n\n\t\treturn extractPrimaryKeyValues(model, keys);\n\t}\n\n\t/**\n\t * Common metadata for `save` operation\n\t * used by individual storage adapters\n\t *\n\t * @param model\n\t */\n\tprotected saveMetadata<T extends PersistentModel>(\n\t\tmodel: T\n\t): {\n\t\tstoreName: string;\n\t\tset: Set<string>;\n\t\tconnectionStoreNames;\n\t\tmodelKeyValues: string[];\n\t} {\n\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst connectedModels = traverseModel(\n\t\t\tmodelConstructor.name,\n\t\t\tmodel,\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tthis.modelInstanceCreator,\n\t\t\tthis.getModelConstructorByModelName!\n\t\t);\n\n\t\tconst set = new Set<string>();\n\t\tconst connectionStoreNames = Object.values(connectedModels).map(\n\t\t\t({ modelName, item, instance }) => {\n\t\t\t\tconst storeName = getStorename(namespaceName, modelName);\n\t\t\t\tset.add(storeName);\n\t\t\t\tconst keys = getIndexKeys(\n\t\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\t\tmodelName\n\t\t\t\t);\n\t\t\t\treturn { storeName, item, instance, keys };\n\t\t\t}\n\t\t);\n\n\t\tconst modelKeyValues = this.getIndexKeyValuesFromModel(model);\n\n\t\treturn { storeName, set, connectionStoreNames, modelKeyValues };\n\t}\n\n\t/**\n\t * Enforces conditional save. Throws if condition is not met.\n\t * used by individual storage adapters\n\t *\n\t * @param model\n\t */\n\tprotected validateSaveCondition<T extends PersistentModel>(\n\t\tcondition?: ModelPredicate<T>,\n\t\tfromDB?: unknown\n\t): void {\n\t\tif (!(condition && fromDB)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst predicates = ModelPredicateCreator.getPredicates(condition);\n\t\tconst { predicates: predicateObjs, type } = predicates!;\n\n\t\tconst isValid = validatePredicate(fromDB, type, predicateObjs);\n\n\t\tif (!isValid) {\n\t\t\tconst msg = 'Conditional update failed';\n\t\t\tlogger.error(msg, { model: fromDB, condition: predicateObjs });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\t}\n\n\tprotected abstract _get<T>(\n\t\tstoreOrStoreName: IDBPObjectStore | string,\n\t\tkeyArr: string[]\n\t): Promise<T>;\n\n\t/**\n\t * Instantiate models from POJO records returned from the database\n\t *\n\t * @param namespaceName - string model namespace\n\t * @param srcModelName - string model name\n\t * @param records - array of uninstantiated records\n\t * @returns\n\t */\n\tprotected async load<T>(\n\t\tnamespaceName: NAMESPACES,\n\t\tsrcModelName: string,\n\t\trecords: T[]\n\t): Promise<T[]> {\n\t\tconst namespace = this.schema.namespaces[namespaceName];\n\t\tconst relations = namespace.relationships![srcModelName].relationTypes;\n\t\tconst connectionStoreNames = relations.map(({ modelName }) => {\n\t\t\treturn getStorename(namespaceName, modelName);\n\t\t});\n\t\tconst modelConstructor = this.getModelConstructorByModelName!(\n\t\t\tnamespaceName,\n\t\t\tsrcModelName\n\t\t);\n\n\t\tif (connectionStoreNames.length === 0) {\n\t\t\treturn records.map(record =>\n\t\t\t\tthis.modelInstanceCreator(modelConstructor, record)\n\t\t\t);\n\t\t}\n\n\t\treturn records.map(record =>\n\t\t\tthis.modelInstanceCreator(modelConstructor, record)\n\t\t);\n\t}\n\n\t/**\n\t * Extracts operands from a predicate group into an array of key values\n\t * Used in the query method\n\t *\n\t * @param predicates - predicate group\n\t * @param keyPath - string array of key names ['id', 'sortKey']\n\t * @returns string[] of key values\n\t *\n\t * @example\n\t * ```js\n\t * { and:[{ id: { eq: 'abc' }}, { sortKey: { eq: 'def' }}] }\n\t * ```\n\t * Becomes\n\t * ```\n\t * ['abc', 'def']\n\t * ```\n\t */\n\tprivate keyValueFromPredicate<T extends PersistentModel>(\n\t\tpredicates: PredicatesGroup<T>,\n\t\tkeyPath: string[]\n\t): string[] | undefined {\n\t\tconst { predicates: predicateObjs } = predicates;\n\n\t\tif (predicateObjs.length !== keyPath.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst keyValues = [] as any[];\n\n\t\tfor (const key of keyPath) {\n\t\t\tconst predicateObj = predicateObjs.find(\n\t\t\t\tp =>\n\t\t\t\t\t// it's a relevant predicate object only if it's an equality\n\t\t\t\t\t// operation for a key field from the key:\n\t\t\t\t\tisPredicateObj(p) &&\n\t\t\t\t\tp.field === key &&\n\t\t\t\t\tp.operator === 'eq' &&\n\t\t\t\t\tp.operand !== null &&\n\t\t\t\t\tp.operand !== undefined\n\t\t\t) as PredicateObject<T>;\n\n\t\t\tpredicateObj && keyValues.push(predicateObj.operand);\n\t\t}\n\n\t\treturn keyValues.length === keyPath.length ? keyValues : undefined;\n\t}\n\n\t/**\n\t * Common metadata for `query` operation\n\t * used by individual storage adapters\n\t *\n\t * @param modelConstructor\n\t * @param predicate\n\t * @param pagination\n\t */\n\tprotected queryMetadata<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t) {\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst namespaceName = this.namespaceResolver(\n\t\t\tmodelConstructor\n\t\t) as NAMESPACES;\n\n\t\tconst predicates =\n\t\t\tpredicate && ModelPredicateCreator.getPredicates(predicate);\n\t\tconst keyPath = getIndexKeys(\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tmodelConstructor.name\n\t\t);\n\t\tconst queryByKey =\n\t\t\tpredicates && this.keyValueFromPredicate(predicates, keyPath);\n\n\t\tconst hasSort = pagination && pagination.sort;\n\t\tconst hasPagination = pagination && pagination.limit;\n\n\t\treturn {\n\t\t\tstoreName,\n\t\t\tnamespaceName,\n\t\t\tqueryByKey,\n\t\t\tpredicates,\n\t\t\thasSort,\n\t\t\thasPagination,\n\t\t};\n\t}\n\n\t/**\n\t * Delete record\n\t * Cascades to related records (for Has One and Has Many relationships)\n\t *\n\t * @param modelOrModelConstructor\n\t * @param condition\n\t * @returns\n\t */\n\tpublic async delete<T extends PersistentModel>(\n\t\tmodelOrModelConstructor: T | PersistentModelConstructor<T>,\n\t\tcondition?: ModelPredicate<T>\n\t): Promise<[T[], T[]]> {\n\t\tawait this.preOpCheck();\n\n\t\tconst deleteQueue: { storeName: string; items: T[] }[] = [];\n\n\t\tif (isModelConstructor(modelOrModelConstructor)) {\n\t\t\tconst modelConstructor =\n\t\t\t\tmodelOrModelConstructor as PersistentModelConstructor<T>;\n\t\t\tconst namespace = this.namespaceResolver(modelConstructor) as NAMESPACES;\n\n\t\t\tconst models = await this.query(modelConstructor, condition);\n\t\t\tconst relations =\n\t\t\t\tthis.schema.namespaces![namespace].relationships![modelConstructor.name]\n\t\t\t\t\t.relationTypes;\n\n\t\t\tif (condition !== undefined) {\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\tmodels,\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnamespace,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\n\t\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t\t<T[]>[]\n\t\t\t\t);\n\n\t\t\t\treturn [models, deletedModels];\n\t\t\t} else {\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\tmodels,\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnamespace,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\n\t\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t\t<T[]>[]\n\t\t\t\t);\n\n\t\t\t\treturn [models, deletedModels];\n\t\t\t}\n\t\t} else {\n\t\t\tconst model = modelOrModelConstructor as T;\n\n\t\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\t\tconst namespaceName = this.namespaceResolver(\n\t\t\t\tmodelConstructor\n\t\t\t) as NAMESPACES;\n\n\t\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\n\t\t\tif (condition) {\n\t\t\t\tconst keyValues = this.getIndexKeyValuesFromModel(model);\n\t\t\t\tconst fromDB = await this._get(storeName, keyValues);\n\n\t\t\t\tif (fromDB === undefined) {\n\t\t\t\t\tconst msg = 'Model instance not found in storage';\n\t\t\t\t\tlogger.warn(msg, { model });\n\n\t\t\t\t\treturn [[model], []];\n\t\t\t\t}\n\n\t\t\t\tconst predicates = ModelPredicateCreator.getPredicates(condition);\n\t\t\t\tconst { predicates: predicateObjs, type } =\n\t\t\t\t\tpredicates as PredicatesGroup<T>;\n\n\t\t\t\tconst isValid = validatePredicate(fromDB as T, type, predicateObjs);\n\t\t\t\tif (!isValid) {\n\t\t\t\t\tconst msg = 'Conditional update failed';\n\t\t\t\t\tlogger.error(msg, { model: fromDB, condition: predicateObjs });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tconst relations =\n\t\t\t\t\tthis.schema.namespaces[namespaceName].relationships![\n\t\t\t\t\t\tmodelConstructor.name\n\t\t\t\t\t].relationTypes;\n\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\t[model],\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnamespaceName,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst relations =\n\t\t\t\t\tthis.schema.namespaces[namespaceName].relationships![\n\t\t\t\t\t\tmodelConstructor.name\n\t\t\t\t\t].relationTypes;\n\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\t[model],\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnamespaceName,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t<T[]>[]\n\t\t\t);\n\n\t\t\treturn [[model], deletedModels];\n\t\t}\n\t}\n\n\tprotected abstract deleteItem<T extends PersistentModel>(\n\t\tdeleteQueue?: {\n\t\t\tstoreName: string;\n\t\t\titems: T[] | IDBValidKey[];\n\t\t}[]\n\t);\n\n\tprotected abstract getHasOneChild<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tsrcModel: string,\n\t\tnamespace: NAMESPACES,\n\t\trel: RelationType\n\t): Promise<T | undefined>;\n\n\t/**\n\t * Backwards compatability for pre-CPK codegen\n\t * TODO - deprecate this in v6; will need to re-gen MIPR for older unit\n\t * tests that hit this path\n\t */\n\tprotected abstract getHasOneChildLegacy<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tsrcModel: string,\n\t\tnamespace: NAMESPACES,\n\t\trel: RelationType\n\t): Promise<T | undefined>;\n\n\tprotected abstract getHasManyChildren<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tindex: string,\n\t\tkeyValues: string[]\n\t): Promise<T[] | undefined>;\n\n\t/**\n\t * Recursively traverse relationship graph and add\n\t * all Has One and Has Many relations to `deleteQueue` param\n\t *\n\t * Actual deletion of records added to `deleteQueue` occurs in the `delete` method\n\t *\n\t * @param relations\n\t * @param models\n\t * @param srcModel\n\t * @param namespace\n\t * @param deleteQueue\n\t */\n\tprotected async deleteTraverse<T extends PersistentModel>(\n\t\trelations: RelationType[],\n\t\tmodels: T[],\n\t\tsrcModel: string,\n\t\tnamespace: NAMESPACES,\n\t\tdeleteQueue: { storeName: string; items: T[] }[]\n\t): Promise<void> {\n\t\tfor await (const rel of relations) {\n\t\t\tconst { modelName, relationType, targetNames, associatedWith } = rel;\n\n\t\t\tconst storeName = getStorename(namespace, modelName);\n\t\t\tconst index: string =\n\t\t\t\tgetIndex(\n\t\t\t\t\tthis.schema.namespaces[namespace].relationships![modelName]\n\t\t\t\t\t\t.relationTypes,\n\t\t\t\t\tsrcModel\n\t\t\t\t) ||\n\t\t\t\t// if we were unable to find an index via relationTypes\n\t\t\t\t// i.e. for keyName connections, attempt to find one by the\n\t\t\t\t// associatedWith property\n\t\t\t\tgetIndexFromAssociation(\n\t\t\t\t\tthis.schema.namespaces[namespace].relationships![modelName].indexes,\n\t\t\t\t\tassociatedWith!\n\t\t\t\t)!;\n\n\t\t\tfor await (const model of models) {\n\t\t\t\tconst childRecords: PersistentModel[] = [];\n\n\t\t\t\tswitch (relationType) {\n\t\t\t\t\tcase 'HAS_ONE':\n\t\t\t\t\t\tlet childRecord;\n\t\t\t\t\t\tif (targetNames?.length) {\n\t\t\t\t\t\t\tchildRecord = await this.getHasOneChild(\n\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\tsrcModel,\n\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\trel\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchildRecord = await this.getHasOneChildLegacy(\n\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\tsrcModel,\n\t\t\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\t\t\trel\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (childRecord) {\n\t\t\t\t\t\t\tchildRecords.push(childRecord);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'HAS_MANY':\n\t\t\t\t\t\tconst keyValues: string[] = this.getIndexKeyValuesFromModel(model);\n\n\t\t\t\t\t\tconst records = await this.getHasManyChildren(\n\t\t\t\t\t\t\tstoreName,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\tkeyValues\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (records?.length) {\n\t\t\t\t\t\t\tchildRecords.push(...records);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'BELONGS_TO':\n\t\t\t\t\t\t// Intentionally blank\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Invalid relation type ${relationType}`);\n\t\t\t\t}\n\n\t\t\t\t// instantiate models before passing them to next recursive call\n\t\t\t\t// necessary for extracting PK metadata in `getHasOneChild` and `getHasManyChildren`\n\t\t\t\tconst childModels = await this.load(namespace, modelName, childRecords);\n\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\tthis.schema.namespaces[namespace].relationships![modelName]\n\t\t\t\t\t\t.relationTypes,\n\t\t\t\t\tchildModels,\n\t\t\t\t\tmodelName,\n\t\t\t\t\tnamespace,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tdeleteQueue.push({\n\t\t\tstoreName: getStorename(namespace, srcModel),\n\t\t\titems: models.map(record =>\n\t\t\t\tthis.modelInstanceCreator(\n\t\t\t\t\tthis.getModelConstructorByModelName!(namespace, srcModel),\n\t\t\t\t\trecord\n\t\t\t\t)\n\t\t\t),\n\t\t});\n\t}\n}\n"],"mappings":";AAAA,SAASA,aAAa,IAAIC,MAAM,QAAQ,mBAAmB;AAG3D,SAASC,qBAAqB,QAAQ,kBAAkB;AACxD,SAECC,cAAc,QAYR,aAAa;AACpB,SAECC,YAAY,EACZC,YAAY,EACZC,uBAAuB,EACvBC,aAAa,EACbC,iBAAiB,EACjBC,QAAQ,EACRC,uBAAuB,EACvBC,kBAAkB,QACZ,YAAY;AAInB,IAAMC,MAAM,GAAG,IAAIX,MAAM,CAAC,WAAW,CAAC;AACtC,IAAMY,OAAO,GAAG,mBAAmB;AAEnC,IAAAC,kBAAA;EAAA,SAAAA,mBAAA;IAcW,KAAAC,MAAM,GAAWF,OAAO;EA4kBnC;EArkBC;;;;;;;;;EASaC,kBAAA,CAAAE,SAAA,CAAAC,KAAK,GAAlB,UACCC,SAAyB,EACzBC,iBAAoC,EACpCC,oBAA0C,EAC1CC,8BAGoC,EACpCC,SAAkB;;;;;;;YAElB,qBAAM,IAAI,CAACC,cAAc,EAAE;;YAA3BC,EAAA,CAAAC,IAAA,EAA2B;iBAEvB,CAAC,IAAI,CAACC,WAAW,EAAjB;YACH,IAAI,CAACA,WAAW,GAAG,IAAIC,OAAO,CAAC,UAACC,GAAG,EAAEC,GAAG;cACvCC,KAAI,CAACC,OAAO,GAAGH,GAAG;cAClBE,KAAI,CAACE,MAAM,GAAGH,GAAG;YAClB,CAAC,CAAC;;;YAEF,qBAAM,IAAI,CAACH,WAAW;;YAAtBF,EAAA,CAAAC,IAAA,EAAsB;YACtB;;YAED,IAAIH,SAAS,EAAE;cACd,IAAI,CAACP,MAAM,GAAMF,OAAO,SAAIS,SAAW;;YAExC,IAAI,CAACW,MAAM,GAAGf,SAAS;YACvB,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;YAC1C,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;YAChD,IAAI,CAACC,8BAA8B,GAAGA,8BAA8B;;;;iBAG/D,CAAC,IAAI,CAACa,EAAE,EAAR;YACHC,EAAA,OAAI;YAAM,qBAAM,IAAI,CAACC,MAAM,EAAE;;YAA7BD,EAAA,CAAKD,EAAE,GAAGV,EAAA,CAAAC,IAAA,EAAmB;YAC7B,IAAI,CAACM,OAAO,EAAE;;;;;;YAGf,IAAI,CAACC,MAAM,CAACK,OAAK,CAAC;;;;;;;GAEnB;EA8BD;;;;EAIUvB,kBAAA,CAAAE,SAAA,CAAAsB,oBAAoB,GAA9B,UACCC,gBAAiD;IAEjD,IAAMC,SAAS,GAAG,IAAI,CAACrB,iBAAiB,CAACoB,gBAAgB,CAAC;IAClD,IAAAE,SAAA,GAAAF,gBAAA,CAAAG,IAAe;IAEvB,OAAOtC,YAAY,CAACoC,SAAS,EAAEC,SAAS,CAAC;EAC1C,CAAC;EAED;;;;;EAKU3B,kBAAA,CAAAE,SAAA,CAAA2B,0BAA0B,GAApC,UACCC,KAAQ;IAER,IAAML,gBAAgB,GAAGM,MAAM,CAACC,cAAc,CAACF,KAAK,CAAC,CACnDG,WAA4C;IAC9C,IAAMC,aAAa,GAAG,IAAI,CAAC7B,iBAAiB,CAACoB,gBAAgB,CAAC;IAE9D,IAAMU,IAAI,GAAG5C,YAAY,CACxB,IAAI,CAAC4B,MAAM,CAACiB,UAAU,CAACF,aAAa,CAAC,EACrCT,gBAAgB,CAACG,IAAI,CACrB;IAED,OAAOpC,uBAAuB,CAACsC,KAAK,EAAEK,IAAI,CAAC;EAC5C,CAAC;EAED;;;;;;EAMUnC,kBAAA,CAAAE,SAAA,CAAAmC,YAAY,GAAtB,UACCP,KAAQ;IADT,IAAAd,KAAA;IAQC,IAAMS,gBAAgB,GAAGM,MAAM,CAACC,cAAc,CAACF,KAAK,CAAC,CACnDG,WAA4C;IAC9C,IAAMK,SAAS,GAAG,IAAI,CAACd,oBAAoB,CAACC,gBAAgB,CAAC;IAC7D,IAAMS,aAAa,GAAG,IAAI,CAAC7B,iBAAiB,CAACoB,gBAAgB,CAAC;IAE9D,IAAMc,eAAe,GAAG9C,aAAa,CACpCgC,gBAAgB,CAACG,IAAI,EACrBE,KAAK,EACL,IAAI,CAACX,MAAM,CAACiB,UAAU,CAACF,aAAa,CAAC,EACrC,IAAI,CAAC5B,oBAAoB,EACzB,IAAI,CAACC,8BAA+B,CACpC;IAED,IAAMiC,GAAG,GAAG,IAAIC,GAAG,EAAU;IAC7B,IAAMC,oBAAoB,GAAGX,MAAM,CAACY,MAAM,CAACJ,eAAe,CAAC,CAACK,GAAG,CAC9D,UAACvB,EAA6B;UAA3BM,SAAA,GAAAN,EAAA,CAAAM,SAAS;QAAEkB,IAAA,GAAAxB,EAAA,CAAAwB,IAAI;QAAEC,QAAA,GAAAzB,EAAA,CAAAyB,QAAQ;MAC3B,IAAMR,SAAS,GAAGhD,YAAY,CAAC4C,aAAa,EAAEP,SAAS,CAAC;MACxDa,GAAG,CAACO,GAAG,CAACT,SAAS,CAAC;MAClB,IAAMH,IAAI,GAAG5C,YAAY,CACxByB,KAAI,CAACG,MAAM,CAACiB,UAAU,CAACF,aAAa,CAAC,EACrCP,SAAS,CACT;MACD,OAAO;QAAEW,SAAS,EAAAA,SAAA;QAAEO,IAAI,EAAAA,IAAA;QAAEC,QAAQ,EAAAA,QAAA;QAAEX,IAAI,EAAAA;MAAA,CAAE;IAC3C,CAAC,CACD;IAED,IAAMa,cAAc,GAAG,IAAI,CAACnB,0BAA0B,CAACC,KAAK,CAAC;IAE7D,OAAO;MAAEQ,SAAS,EAAAA,SAAA;MAAEE,GAAG,EAAAA,GAAA;MAAEE,oBAAoB,EAAAA,oBAAA;MAAEM,cAAc,EAAAA;IAAA,CAAE;EAChE,CAAC;EAED;;;;;;EAMUhD,kBAAA,CAAAE,SAAA,CAAA+C,qBAAqB,GAA/B,UACCC,SAA6B,EAC7BC,MAAgB;IAEhB,IAAI,EAAED,SAAS,IAAIC,MAAM,CAAC,EAAE;MAC3B;;IAGD,IAAMC,UAAU,GAAGhE,qBAAqB,CAACiE,aAAa,CAACH,SAAS,CAAC;IAC3D,IAAA7B,EAAA,GAAA+B,UAAiD;MAA/CE,aAAA,GAAAjC,EAAA,CAAA+B,UAAyB;MAAEG,IAAA,GAAAlC,EAAA,CAAAkC,IAAoB;IAEvD,IAAMC,OAAO,GAAG9D,iBAAiB,CAACyD,MAAM,EAAEI,IAAI,EAAED,aAAa,CAAC;IAE9D,IAAI,CAACE,OAAO,EAAE;MACb,IAAMC,GAAG,GAAG,2BAA2B;MACvC3D,MAAM,CAAC4D,KAAK,CAACD,GAAG,EAAE;QAAE3B,KAAK,EAAEqB,MAAM;QAAED,SAAS,EAAEI;MAAa,CAAE,CAAC;MAE9D,MAAM,IAAIK,KAAK,CAACF,GAAG,CAAC;;EAEtB,CAAC;EAOD;;;;;;;;EAQgBzD,kBAAA,CAAAE,SAAA,CAAA0D,IAAI,GAApB,UACC1B,aAAyB,EACzB2B,YAAoB,EACpBC,OAAY;;;;;QAENpC,SAAS,GAAG,IAAI,CAACP,MAAM,CAACiB,UAAU,CAACF,aAAa,CAAC;QACjD6B,SAAS,GAAGrC,SAAS,CAACsC,aAAc,CAACH,YAAY,CAAC,CAACI,aAAa;QAChEvB,oBAAoB,GAAGqB,SAAS,CAACnB,GAAG,CAAC,UAACvB,EAAa;cAAXM,SAAA,GAAAN,EAAA,CAAAM,SAAS;UACtD,OAAOrC,YAAY,CAAC4C,aAAa,EAAEP,SAAS,CAAC;QAC9C,CAAC,CAAC;QACIF,gBAAgB,GAAG,IAAI,CAAClB,8BAA+B,CAC5D2B,aAAa,EACb2B,YAAY,CACZ;QAED,IAAInB,oBAAoB,CAACwB,MAAM,KAAK,CAAC,EAAE;UACtC,sBAAOJ,OAAO,CAAClB,GAAG,CAAC,UAAAuB,MAAM;YACxB,OAAAnD,KAAI,CAACV,oBAAoB,CAACmB,gBAAgB,EAAE0C,MAAM,CAAC;UAAnD,CAAmD,CACnD;;QAGF,sBAAOL,OAAO,CAAClB,GAAG,CAAC,UAAAuB,MAAM;UACxB,OAAAnD,KAAI,CAACV,oBAAoB,CAACmB,gBAAgB,EAAE0C,MAAM,CAAC;QAAnD,CAAmD,CACnD;;;GACD;EAED;;;;;;;;;;;;;;;;;EAiBQnE,kBAAA,CAAAE,SAAA,CAAAkE,qBAAqB,GAA7B,UACChB,UAA8B,EAC9BiB,OAAiB;;IAET,IAAAf,aAAA,GAAAF,UAAA,CAAAA,UAAyB;IAEjC,IAAIE,aAAa,CAACY,MAAM,KAAKG,OAAO,CAACH,MAAM,EAAE;MAC5C;;IAGD,IAAMI,SAAS,GAAG,EAAW;4BAElBC,GAAG;MACb,IAAMC,YAAY,GAAGlB,aAAa,CAACmB,IAAI,CACtC,UAAAC,CAAC;QACA;QACA;QACA,OAAArF,cAAc,CAACqF,CAAC,CAAC,IACjBA,CAAC,CAACC,KAAK,KAAKJ,GAAG,IACfG,CAAC,CAACE,QAAQ,KAAK,IAAI,IACnBF,CAAC,CAACG,OAAO,KAAK,IAAI,IAClBH,CAAC,CAACG,OAAO,KAAKC,SAAS;MAJvB,CAIuB,CACF;MAEvBN,YAAY,IAAIF,SAAS,CAACS,IAAI,CAACP,YAAY,CAACK,OAAO,CAAC;;;MAZrD,KAAkB,IAAAG,SAAA,GAAAC,QAAA,CAAAZ,OAAO,GAAAa,WAAA,GAAAF,SAAA,CAAAG,IAAA,KAAAD,WAAA,CAAAE,IAAA,EAAAF,WAAA,GAAAF,SAAA,CAAAG,IAAA;QAApB,IAAMZ,GAAG,GAAAW,WAAA,CAAAG,KAAA;gBAAHd,GAAG;;;;;;;;;;;;;IAed,OAAOD,SAAS,CAACJ,MAAM,KAAKG,OAAO,CAACH,MAAM,GAAGI,SAAS,GAAGQ,SAAS;EACnE,CAAC;EAED;;;;;;;;EAQU9E,kBAAA,CAAAE,SAAA,CAAAoF,aAAa,GAAvB,UACC7D,gBAA+C,EAC/C8D,SAA6B,EAC7BC,UAA+B;IAE/B,IAAMlD,SAAS,GAAG,IAAI,CAACd,oBAAoB,CAACC,gBAAgB,CAAC;IAC7D,IAAMS,aAAa,GAAG,IAAI,CAAC7B,iBAAiB,CAC3CoB,gBAAgB,CACF;IAEf,IAAM2B,UAAU,GACfmC,SAAS,IAAInG,qBAAqB,CAACiE,aAAa,CAACkC,SAAS,CAAC;IAC5D,IAAMlB,OAAO,GAAG9E,YAAY,CAC3B,IAAI,CAAC4B,MAAM,CAACiB,UAAU,CAACF,aAAa,CAAC,EACrCT,gBAAgB,CAACG,IAAI,CACrB;IACD,IAAM6D,UAAU,GACfrC,UAAU,IAAI,IAAI,CAACgB,qBAAqB,CAAChB,UAAU,EAAEiB,OAAO,CAAC;IAE9D,IAAMqB,OAAO,GAAGF,UAAU,IAAIA,UAAU,CAACG,IAAI;IAC7C,IAAMC,aAAa,GAAGJ,UAAU,IAAIA,UAAU,CAACK,KAAK;IAEpD,OAAO;MACNvD,SAAS,EAAAA,SAAA;MACTJ,aAAa,EAAAA,aAAA;MACbuD,UAAU,EAAAA,UAAA;MACVrC,UAAU,EAAAA,UAAA;MACVsC,OAAO,EAAAA,OAAA;MACPE,aAAa,EAAAA;KACb;EACF,CAAC;EAED;;;;;;;;EAQa5F,kBAAA,CAAAE,SAAA,CAAA4F,MAAM,GAAnB,UACCC,uBAA0D,EAC1D7C,SAA6B;;;;;;YAE7B,qBAAM,IAAI,CAAC8C,UAAU,EAAE;;YAAvBtF,EAAA,CAAAC,IAAA,EAAuB;YAEjBsF,WAAW,GAAwC,EAAE;iBAEvDpG,kBAAkB,CAACkG,uBAAuB,CAAC,EAA3C;YACGtE,gBAAgB,GACrBsE,uBAAwD;YACnDrE,SAAS,GAAG,IAAI,CAACrB,iBAAiB,CAACoB,gBAAgB,CAAe;YAEzD,qBAAM,IAAI,CAACyE,KAAK,CAACzE,gBAAgB,EAAEyB,SAAS,CAAC;;YAAtDiD,MAAM,GAAGzF,EAAA,CAAAC,IAAA,EAA6C;YACtDoD,SAAS,GACd,IAAI,CAAC5C,MAAM,CAACiB,UAAW,CAACV,SAAS,CAAC,CAACsC,aAAc,CAACvC,gBAAgB,CAACG,IAAI,CAAC,CACtEqC,aAAa;kBAEZf,SAAS,KAAK4B,SAAS,GAAvB;YACH,qBAAM,IAAI,CAACsB,cAAc,CACxBrC,SAAS,EACToC,MAAM,EACN1E,gBAAgB,CAACG,IAAI,EACrBF,SAAS,EACTuE,WAAW,CACX;;YANDvF,EAAA,CAAAC,IAAA,EAMC;YAED,qBAAM,IAAI,CAAC0F,UAAU,CAACJ,WAAW,CAAC;;YAAlCvF,EAAA,CAAAC,IAAA,EAAkC;YAE5B2F,aAAa,GAAGL,WAAW,CAACM,MAAM,CACvC,UAACC,GAAG,EAAEnF,EAAS;kBAAPoF,KAAA,GAAApF,EAAA,CAAAoF,KAAK;cAAO,OAAAD,GAAG,CAACE,MAAM,CAACD,KAAK,CAAC;YAAjB,CAAiB,EAChC,EAAE,CACP;YAED,sBAAO,CAACN,MAAM,EAAEG,aAAa,CAAC;;YAE9B,qBAAM,IAAI,CAACF,cAAc,CACxBrC,SAAS,EACToC,MAAM,EACN1E,gBAAgB,CAACG,IAAI,EACrBF,SAAS,EACTuE,WAAW,CACX;;YANDvF,EAAA,CAAAC,IAAA,EAMC;YAED,qBAAM,IAAI,CAAC0F,UAAU,CAACJ,WAAW,CAAC;;YAAlCvF,EAAA,CAAAC,IAAA,EAAkC;YAE5B2F,aAAa,GAAGL,WAAW,CAACM,MAAM,CACvC,UAACC,GAAG,EAAEnF,EAAS;kBAAPoF,KAAA,GAAApF,EAAA,CAAAoF,KAAK;cAAO,OAAAD,GAAG,CAACE,MAAM,CAACD,KAAK,CAAC;YAAjB,CAAiB,EAChC,EAAE,CACP;YAED,sBAAO,CAACN,MAAM,EAAEG,aAAa,CAAC;;;;YAGzBxE,KAAK,GAAGiE,uBAA4B;YAEpCtE,gBAAgB,GAAGM,MAAM,CAACC,cAAc,CAACF,KAAK,CAAC,CACnDG,WAA4C;YACxCC,aAAa,GAAG,IAAI,CAAC7B,iBAAiB,CAC3CoB,gBAAgB,CACF;YAETa,SAAS,GAAG,IAAI,CAACd,oBAAoB,CAACC,gBAAgB,CAAC;iBAEzDyB,SAAS,EAAT;YACGoB,SAAS,GAAG,IAAI,CAACzC,0BAA0B,CAACC,KAAK,CAAC;YACzC,qBAAM,IAAI,CAAC6E,IAAI,CAACrE,SAAS,EAAEgC,SAAS,CAAC;;YAA9CnB,MAAM,GAAGzC,EAAA,CAAAC,IAAA,EAAqC;YAEpD,IAAIwC,MAAM,KAAK2B,SAAS,EAAE;cACnBrB,GAAG,GAAG,qCAAqC;cACjD3D,MAAM,CAAC8G,IAAI,CAACnD,GAAG,EAAE;gBAAE3B,KAAK,EAAAA;cAAA,CAAE,CAAC;cAE3B,sBAAO,CAAC,CAACA,KAAK,CAAC,EAAE,EAAE,CAAC;;YAGfsB,UAAU,GAAGhE,qBAAqB,CAACiE,aAAa,CAACH,SAAS,CAAC;YAC3D7B,EAAA,GACL+B,UAAgC,EADbE,aAAa,GAAAjC,EAAA,CAAA+B,UAAA,EAAEG,IAAI,GAAAlC,EAAA,CAAAkC,IAAA;YAGjCC,OAAO,GAAG9D,iBAAiB,CAACyD,MAAW,EAAEI,IAAI,EAAED,aAAa,CAAC;YACnE,IAAI,CAACE,OAAO,EAAE;cACPC,GAAG,GAAG,2BAA2B;cACvC3D,MAAM,CAAC4D,KAAK,CAACD,GAAG,EAAE;gBAAE3B,KAAK,EAAEqB,MAAM;gBAAED,SAAS,EAAEI;cAAa,CAAE,CAAC;cAE9D,MAAM,IAAIK,KAAK,CAACF,GAAG,CAAC;;YAGfM,SAAS,GACd,IAAI,CAAC5C,MAAM,CAACiB,UAAU,CAACF,aAAa,CAAC,CAAC8B,aAAc,CACnDvC,gBAAgB,CAACG,IAAI,CACrB,CAACqC,aAAa;YAEhB,qBAAM,IAAI,CAACmC,cAAc,CACxBrC,SAAS,EACT,CAACjC,KAAK,CAAC,EACPL,gBAAgB,CAACG,IAAI,EACrBM,aAAa,EACb+D,WAAW,CACX;;YANDvF,EAAA,CAAAC,IAAA,EAMC;;;YAEKoD,SAAS,GACd,IAAI,CAAC5C,MAAM,CAACiB,UAAU,CAACF,aAAa,CAAC,CAAC8B,aAAc,CACnDvC,gBAAgB,CAACG,IAAI,CACrB,CAACqC,aAAa;YAEhB,qBAAM,IAAI,CAACmC,cAAc,CACxBrC,SAAS,EACT,CAACjC,KAAK,CAAC,EACPL,gBAAgB,CAACG,IAAI,EACrBM,aAAa,EACb+D,WAAW,CACX;;YANDvF,EAAA,CAAAC,IAAA,EAMC;;;YAEF,qBAAM,IAAI,CAAC0F,UAAU,CAACJ,WAAW,CAAC;;YAAlCvF,EAAA,CAAAC,IAAA,EAAkC;YAE5B2F,aAAa,GAAGL,WAAW,CAACM,MAAM,CACvC,UAACC,GAAG,EAAEnF,EAAS;kBAAPoF,KAAA,GAAApF,EAAA,CAAAoF,KAAK;cAAO,OAAAD,GAAG,CAACE,MAAM,CAACD,KAAK,CAAC;YAAjB,CAAiB,EAChC,EAAE,CACP;YAED,sBAAO,CAAC,CAAC3E,KAAK,CAAC,EAAEwE,aAAa,CAAC;;;;;;GAEhC;EAkCD;;;;;;;;;;;;EAYgBtG,kBAAA,CAAAE,SAAA,CAAAkG,cAAc,GAA9B,UACCrC,SAAyB,EACzBoC,MAAW,EACXU,QAAgB,EAChBnF,SAAqB,EACrBuE,WAAgD;;;;;;;;;;YAExBa,WAAA,GAAAC,aAAA,CAAAhD,SAAS;;;;;;YAAhBiD,GAAG,GAAAC,aAAA,CAAA5B,KAAA;YACX1D,SAAS,GAAgDqF,GAAG,CAAArF,SAAnD,EAAEuF,YAAY,GAAkCF,GAAG,CAAAE,YAArC,EAAEC,WAAW,GAAqBH,GAAG,CAAAG,WAAxB,EAAEC,cAAc,GAAKJ,GAAG,CAAAI,cAAR;YAEtD9E,SAAS,GAAGhD,YAAY,CAACoC,SAAS,EAAEC,SAAS,CAAC;YAC9C0F,KAAK,GACV1H,QAAQ,CACP,IAAI,CAACwB,MAAM,CAACiB,UAAU,CAACV,SAAS,CAAC,CAACsC,aAAc,CAACrC,SAAS,CAAC,CACzDsC,aAAa,EACf4C,QAAQ,CACR;YACD;YACA;YACA;YACAjH,uBAAuB,CACtB,IAAI,CAACuB,MAAM,CAACiB,UAAU,CAACV,SAAS,CAAC,CAACsC,aAAc,CAACrC,SAAS,CAAC,CAAC2F,OAAO,EACnEF,cAAe,CACd;;;;YAEuBG,QAAA,GAAAR,aAAA,CAAAZ,MAAM;;;;;;YAAfrE,KAAK,GAAA0F,UAAA,CAAAnC,KAAA;YACfoC,YAAY,GAAsB,EAAE;YAElCC,EAAA,GAAAR,YAAY;;mBACd,SAAS;gBAAT;mBAuBA,UAAU;gBAAV;mBAcA,YAAY;gBAAZ;YAAY;;;YApCZS,WAAW;kBACXR,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEjD,MAAM;YACR,qBAAM,IAAI,CAAC0D,cAAc,CACtC9F,KAAK,EACL+E,QAAQ,EACRnF,SAAS,EACTsF,GAAG,CACH;;YALDW,WAAW,GAAGE,EAAA,CAAAlH,IAAA,EAKb;;;YAEa,qBAAM,IAAI,CAACmH,oBAAoB,CAC5ChG,KAAK,EACL+E,QAAQ,EACRnF,SAAS,EACTsF,GAAG,CACH;;YALDW,WAAW,GAAGE,EAAA,CAAAlH,IAAA,EAKb;;;YAGF,IAAIgH,WAAW,EAAE;cAChBF,YAAY,CAAC1C,IAAI,CAAC4C,WAAW,CAAC;;YAG/B;;YAEMrD,SAAS,GAAa,IAAI,CAACzC,0BAA0B,CAACC,KAAK,CAAC;YAElD,qBAAM,IAAI,CAACiG,kBAAkB,CAC5CzF,SAAS,EACT+E,KAAK,EACL/C,SAAS,CACT;;YAJKR,OAAO,GAAG+D,EAAA,CAAAlH,IAAA,EAIf;YAED,IAAImD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEI,MAAM,EAAE;cACpBuD,YAAY,CAAC1C,IAAI,CAAAiD,KAAA,CAAjBP,YAAY,EAAAQ,QAAA,CAASnE,OAAO;;YAG7B;;YAEA;YACA;;YAEA,MAAM,IAAIH,KAAK,CAAC,2BAAyBuD,YAAc,CAAC;;YAKtC,qBAAM,IAAI,CAACtD,IAAI,CAAClC,SAAS,EAAEC,SAAS,EAAE8F,YAAY,CAAC;;YAAjES,WAAW,GAAGL,EAAA,CAAAlH,IAAA,EAAmD;YAEvE,qBAAM,IAAI,CAACyF,cAAc,CACxB,IAAI,CAACjF,MAAM,CAACiB,UAAU,CAACV,SAAS,CAAC,CAACsC,aAAc,CAACrC,SAAS,CAAC,CACzDsC,aAAa,EACfiE,WAAW,EACXvG,SAAS,EACTD,SAAS,EACTuE,WAAW,CACX;;YAPD4B,EAAA,CAAAlH,IAAA,EAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;YAIHsF,WAAW,CAAClB,IAAI,CAAC;cAChBzC,SAAS,EAAEhD,YAAY,CAACoC,SAAS,EAAEmF,QAAQ,CAAC;cAC5CJ,KAAK,EAAEN,MAAM,CAACvD,GAAG,CAAC,UAAAuB,MAAM;gBACvB,OAAAnD,KAAI,CAACV,oBAAoB,CACxBU,KAAI,CAACT,8BAA+B,CAACmB,SAAS,EAAEmF,QAAQ,CAAC,EACzD1C,MAAM,CACN;cAHD,CAGC;aAEF,CAAC;;;;;GACF;;EACF,OAAAnE,kBAAC;AAAD,CAAC,EA1lBD"},"metadata":{},"sourceType":"module","externalDependencies":[]}